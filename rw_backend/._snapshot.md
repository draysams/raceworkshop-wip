
---

### **Project Handover Document: RaceWorkshop (v2)**

**To:** The New Development Team
**From:** The Previous Lead Developer & Architect
**Date:** July 24, 2025
**Re:** Complete Project Context, Architecture, Known Bugs, and Path to Completion

Welcome to the RaceWorkshop team. You are taking over a project at a pivotal and exciting moment. We have successfully laid a robust, modern architectural foundation for a high-performance sim racing telemetry application. This document will serve as your starting point to get you up to speed and guide you to a successful version 1.0 launch.

### **1. Project Vision & Core Goal**

RaceWorkshop is an enterprise-grade desktop application for sim racing enthusiasts and professionals. Its mission is to provide a beautiful, intuitive UI to capture, analyze, and persist high-fidelity lap and telemetry data.

The core technical differentiator is its reliance on **direct shared memory access** instead of slower API polling, enabling a truly "live" data feed. Architecturally, it is designed as a **persistent data logger**: a background service that reliably records all on-track activity, even if the main UI window is closed, ensuring no data is ever lost.

### **2. Developer Workflow & How to Run the Project**

This project uses a combination of Python for the backend and a React/TypeScript frontend. The `npm` command runner is used as the primary tool for managing the development lifecycle.

#### **2.1. Initial Setup**

1.  **Clone the repository.**
2.  **Install Python dependencies:**
    *   Create and activate a Python virtual environment:
        ```bash
        python -m venv venv
        # Windows:
        venv\Scripts\activate
        # macOS/Linux:
        source venv/bin/activate
        ```
    *   Install all required packages:
        ```bash
        pip install -r requirements.txt
        ```
3.  **Install Frontend dependencies:**
    *   From the project's **root directory**, run:
        ```bash
        npm install
        ```
    *   This command will also automatically run `npm install` inside the `frontend/` directory (due to the `postinstall` script in `package.json`).

#### **2.2. Running in Development Mode (with Hot Reloading)**

This is the primary mode you will use for development. It starts the Vite server for instant UI updates and runs the Python backend, connecting them together.

*   **Prerequisites:** Your Python virtual environment must be activated.
*   **Command:** From the project root, run:
    ```bash
    npm run dev
    ```
*   **What it does:** This command uses `concurrently` to launch two processes in your terminal:
    1.  **The Vite Dev Server:** Serves the React UI from memory on `http://localhost:5173`.
    2.  **The Python Backend (`main.py`):** Launches the main UI window. The `RACEWORKSHOP_DEV_MODE=1` environment variable tells it to load the UI from the Vite server's URL, enabling hot reloading.
*   **Workflow:** When you save a change in a `.tsx` or `.css` file, the UI in the desktop window will update instantly without needing to restart the application.

#### **2.3. Running in Production Mode (Testing a Build)**

This mode simulates how the final application will run for an end-user. It builds the static UI files and runs the Python backend, loading from those files.

*   **Prerequisites:** Your Python virtual environment must be activated.
*   **Command:** From the project root, run:
    ```bash
    npm start
    ```
*   **What it does:**
    1.  First, it runs `npm run build`, which compiles your React app into a static `frontend/dist` folder.
    2.  Then, it runs `python main.py`. Since the `DEV_MODE` variable is not set, `main.py` will load its UI from the local `frontend/dist/index.html` file.

### **3. Current State of the Project**

The project has successfully completed the foundational architectural work and is at the **end of Chunk 4**, focused on perfecting the data recording logic.

*   **Technology Stack:** The application has been successfully migrated from an Electron/Node.js prototype to a **Python / Pywebview** stack.
*   **Live Data Pipeline:** **This is fully functional.** The daemon can connect to Le Mans Ultimate's shared memory, process the data in real-time, and stream live telemetry (Speed, RPM, etc.) over a WebSocket to the React frontend. The "Live Transponder" UI works.
*   **Architecture:** The backend is a robust, decoupled, **event-driven pipeline**. This is the core strength of the current design.
*   **Database Persistence:** The `Session` records are being created and closed correctly.

### **4. Current Known Bugs (Your Immediate Priority)**

Your first task will be to resolve the known bugs in the data recording logic by making a targeted change to the `EventGenerator`.

1.  **In-Lap Data is Lost:**
    *   **Symptom:** A `StintEnded` event is dispatched *before* the `LapCompleted` event for the lap that enters the pits. This results in a `[LapHandler] WARNING: Received LapCompleted but no active stint`.
    *   **Root Cause:** A race condition in the `EventGenerator`'s main loop. Stint detection is running before lap detection.
    *   **Required Fix:** Reorder the calls in the `EventGenerator.run()` method to ensure `detect_lap_events()` is always called *before* `detect_stint_events()`.

2.  **First Flying Lap Time is Missing:**
    *   **Symptom:** The first timed lap of a stint is recorded with a `NULL` lap time in the database.
    *   **Root Cause:** The logic for capturing the lap time is looking in the wrong frame's data.
    *   **Required Fix:** The `detect_lap_events` method must be modified to use the **previous frame's data** (`self.last_player_data`) to retrieve the `mLastLapTime`, as this is the frame where the time for the just-completed lap is valid.

### **5. System Architecture**

#### **5.1. Process Architecture**

The application runs as two distinct Python processes:

1.  **GUI Process (`main.py`):** The user-facing application.
    *   Launches and terminates the Daemon Process.
    *   Creates the `pywebview` window.
    *   Exposes an `ApiBridge` to the UI's JavaScript for historical data requests.

2.  **Daemon Process (`daemon.py`):** A headless background service.
    *   Connects to the simulator.
    *   Processes all real-time data via the event pipeline.
    *   Writes all session/stint/lap data to the database.
    *   Runs a WebSocket server for live UI updates.

#### **5.2. Backend Event-Driven Architecture**

The `daemon.py` process is built as a pipeline:

1.  **Collector (`collector.py`):** Reads raw data from the sim and puts it on a `raw_data_queue`.
2.  **EventGenerator (`event_generator.py`):** Consumes raw data, detects state changes, and produces high-level **Events** (e.g., `LapCompleted`, `StintStarted`) on an `event_queue`.
3.  **Event Bus (`daemon.py` loop):** Consumes events and dispatches them to all registered handlers.
4.  **Handlers (`handlers/*.py`):** Each handler performs one specific action (e.g., `LapHandler` saves laps to the database).

### **6. File Structure & Responsibilities**

```
raceworkshop-python/
‚îú‚îÄ‚îÄ frontend/                  # React UI Application source
‚îÇ   ‚îî‚îÄ‚îÄ dist/                  # Compiled, static UI files
‚îú‚îÄ‚îÄ rw_backend/                # The Python backend source package
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api_bridge.py      # Python class exposed to JS for historical data
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ events.py          # Defines all event types (e.g., SessionStarted)
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager.py         # Handles DB connection and table creation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models.py          # Peewee ORM models (Session, Stint, Lap)
‚îÇ   ‚îú‚îÄ‚îÄ generators/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ event_generator.py # The "brain" - detects events from raw data
‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session_handler.py # Acts on Session events to write to DB
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stint_handler.py   # Acts on Stint events to write to DB
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lap_handler.py     # Acts on Lap events to write to DB
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ live_data_handler.py # Pushes live data to the UI's WebSocket
‚îÇ   ‚îî‚îÄ‚îÄ simulators/
‚îÇ       ‚îî‚îÄ‚îÄ lmu/
‚îÇ           ‚îî‚îÄ‚îÄ collector.py   # Connects to and reads from LMU's shared memory
‚îú‚îÄ‚îÄ daemon.py                  # Entry point for the background data/event process
‚îú‚îÄ‚îÄ main.py                    # Main user entry point; launches daemon and UI
‚îî‚îÄ‚îÄ package.json               # Manages dev workflow (npm run dev, etc.)
```

### **7. Database Structure**

The database is SQLite, managed by Peewee.

*   **`Session` Table:** One record per gameplay session. Contains `game_session_uid` for crash resumption.
*   **`Stint` Table:** One record for each time the player leaves the pits/garage. Linked to a `Session`.
*   **`Lap` Table:** One record for every lap completed. Linked to a `Stint`. `lap_time` can be NULL for out/in-laps.

### **8. Roadmap to Completion**

1.  **[Current Task] Finalize Chunk 4:**
    *   Apply the targeted fixes to the `EventGenerator` to resolve the two known bugs with lap and stint detection.
    *   Run the comprehensive verification test to ensure all data is being recorded to the database with 100% accuracy.
2.  **Chunk 5: Seamless Operation:**
    *   Implement the `/health` check endpoint in the daemon.
    *   Update `main.py` to check for an existing daemon before launching a new one.
3.  **Chunk 6: Polishing and Packaging:**
    *   Re-enable and test with React Strict Mode.
    *   Clean up all diagnostic print statements.
    *   Use `PyInstaller` to create a distributable `.exe`.

Welcome to the project. Your immediate focus should be on applying the final, targeted fixes to `rw_backend/generators/event_generator.py`. Good luck.


# Project Snapshot: .

## `__init__.py`

```

```

---

## `__pycache__\__init__.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `api\__init__.py`

```

```

---

## `core\__init__.py`

```

```

---

## `core\__pycache__\__init__.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `core\__pycache__\api_bridge.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `core\__pycache__\events.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `core\__pycache__\live_data_server.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `core\api_bridge.py`

```
# rw_backend/core/api_bridge.py

import json
from rw_backend.database.models import Session, Stint, Lap
from rw_backend.dtos.session_dtos import map_session_to_summary_dto, map_lap_to_detail_dto

class ApiBridge:
    def __init__(self):
        pass

    def getSessionHistory(self, filters):
        print("API CALL: getSessionHistory")
        try:
            query = Session.select().order_by(Session.started_at.desc())
            sessions_dto = [map_session_to_summary_dto(s) for s in query]
            return json.dumps(sessions_dto)
        except Exception as e:
            print(f"Error fetching session history: {e}")
            return json.dumps([])

    def getSessionDetail(self, sessionId):
        print(f"API CALL: getSessionDetail for session {sessionId}")
        try:
            session = Session.get_by_id(sessionId)
            laps_query = Lap.select().join(Stint).where(Stint.session == session).order_by(Lap.lap_number)
            
            session_dto = map_session_to_summary_dto(session)
            laps_dto = [map_lap_to_detail_dto(lap) for lap in laps_query]

            return json.dumps({
                'session': session_dto,
                'laps': laps_dto
            })
        except Exception as e:
            print(f"Error fetching session detail: {e}")
            return json.dumps(None)
```

---

## `core\events.py`

```
# rw_backend/core/events.py

from dataclasses import dataclass

@dataclass
class Event:
    """Base class for all events."""
    pass

# --- Session Events ---
@dataclass
class SessionStarted(Event):
    uid: str
    track_name: str
    session_type: str
    player_name: str
    car_model: str
    car_class: str
    track_temp: float
    air_temp: float

@dataclass
class SessionEnded(Event):
    pass

# --- Stint Events ---
@dataclass
class StintStarted(Event):
    lap_number: int

@dataclass
class StintEnded(Event):
    lap_number: int

# --- Lap Events ---
@dataclass
class LapCompleted(Event):
    lap_number: int
    lap_time: float
    sector1_time: float
    sector2_time: float
    sector3_time: float
    is_valid: bool

# --- Live Data Events ---
@dataclass
class TelemetryUpdate(Event):
    """Event to push live data to the UI."""
    payload: dict
```

---

## `core\live_data_server.py`

```
# rw_backend/core/live_data_server.py

import asyncio
import websockets
import threading
import json
from queue import Queue, Empty

class LiveDataServer:
    """
    Manages a WebSocket server to stream live data to the frontend.
    Runs in its own thread.
    """
    def __init__(self, host='localhost', port=8765):
        self.host = host
        self.port = port
        self.clients = set()
        self.data_queue = Queue()
        self.server_thread = threading.Thread(target=self._run_server_in_thread, daemon=True)

    async def _register(self, websocket):
        """Adds a new client and waits for them to disconnect."""
        self.clients.add(websocket)
        print(f"[Live Data Server] Client connected. Total clients: {len(self.clients)}")
        try:
            await websocket.wait_closed()
        finally:
            self.clients.remove(websocket)
            print(f"[Live Data Server] Client disconnected. Total clients: {len(self.clients)}")

    async def _broadcast_data(self):
        """Continuously checks the queue and sends data to all clients."""
        while True:
            try:
                # Use a non-blocking get to avoid halting the async loop
                message = self.data_queue.get_nowait()
                if self.clients:
                    # websockets.broadcast is a convenient way to send to all clients
                    websockets.broadcast(self.clients, message)
            except Empty:
                # If the queue is empty, wait briefly to yield control
                await asyncio.sleep(1 / 100) # Sleep for 10ms

    async def _main(self):
        """The main async function that starts the server and broadcaster."""
        print(f"[Live Data Server] Starting WebSocket server on ws://{self.host}:{self.port}")
        async with websockets.serve(self._register, self.host, self.port):
            await self._broadcast_data()

    def _run_server_in_thread(self):
        """Entry point for the thread, runs the asyncio event loop."""
        try:
            asyncio.run(self._main())
        except Exception as e:
            print(f"[Live Data Server] Thread error: {e}")

    def start(self):
        """Starts the server thread."""
        self.server_thread.start()

    def push_data(self, data: dict):
        """Public, thread-safe method to add data to the broadcast queue."""
        # We serialize to JSON here to offload that work from the server's async loop.
        self.data_queue.put(json.dumps(data))
```

---

## `database\__init__.py`

```

```

---

## `database\__pycache__\__init__.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `database\__pycache__\manager.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `database\__pycache__\models.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `database\manager.py`

```
# rw_backend/database/manager.py
from .models import db, Session, Stint, Lap

def initialize_database():
    """
    Connects to the database and creates the necessary tables
    if they don't already exist.
    """
    try:
        db.connect()
        db.create_tables([Session, Stint, Lap])
        print("Database initialized successfully.", flush=True)
    except Exception as e:
        print(f"Error initializing database: {e}", flush=True)
    finally:
        if not db.is_closed():
            db.close()

def connect_db():
    """Connects to the database if the connection is closed."""
    if db.is_closed():
        db.connect()

def close_db():
    """Closes the database connection if it's open."""
    if not db.is_closed():
        db.close()
```

---

## `database\models.py`

```
# rw_backend/database/models.py
import peewee as pw
import os
from datetime import datetime

app_data_path = os.path.join(os.getenv('APPDATA'), 'RaceWorkshop')
os.makedirs(app_data_path, exist_ok=True)
db_path = os.path.join(app_data_path, 'raceworkshop.db')
db = pw.SqliteDatabase(db_path, pragmas={'foreign_keys': 1})

class BaseModel(pw.Model):
    class Meta:
        database = db

class Session(BaseModel):
    track_name = pw.CharField()
    session_type = pw.CharField()
    player_name = pw.CharField()
    car_model = pw.CharField()
    car_class = pw.CharField()
    started_at = pw.DateTimeField(default=datetime.now)
    ended_at = pw.DateTimeField(null=True)
    track_temp = pw.FloatField(null=True)
    air_temp = pw.FloatField(null=True)
    game_session_uid = pw.CharField(unique=True, null=True)

class Stint(BaseModel):
    session = pw.ForeignKeyField(Session, backref='stints', on_delete='CASCADE')
    stint_number = pw.IntegerField()
    started_on_lap = pw.IntegerField()
    ended_on_lap = pw.IntegerField(null=True)

class Lap(BaseModel):
    stint = pw.ForeignKeyField(Stint, backref='laps', on_delete='CASCADE')
    lap_number = pw.IntegerField()
    lap_time = pw.FloatField()
    sector1_time = pw.FloatField(null=True)
    sector2_time = pw.FloatField(null=True)
    sector3_time = pw.FloatField(null=True)
    is_valid = pw.BooleanField()
    timestamp = pw.DateTimeField(default=datetime.now)
```

---

## `directory-to-markdown\.git\HEAD`

```
ref: refs/heads/main

```

---

## `directory-to-markdown\.git\config`

```
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[remote "origin"]
	url = https://github.com/draysams/directory-to-markdown.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main

```

---

## `directory-to-markdown\.git\description`

```
Unnamed repository; edit this file 'description' to name the repository.

```

---

## `directory-to-markdown\.git\hooks\applypatch-msg.sample`

```
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:

```

---

## `directory-to-markdown\.git\hooks\commit-msg.sample`

```
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}

```

---

## `directory-to-markdown\.git\hooks\fsmonitor-watchman.sample`

```
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}

```

---

## `directory-to-markdown\.git\hooks\post-update.sample`

```
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info

```

---

## `directory-to-markdown\.git\hooks\pre-applypatch.sample`

```
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:

```

---

## `directory-to-markdown\.git\hooks\pre-commit.sample`

```
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --

```

---

## `directory-to-markdown\.git\hooks\pre-merge-commit.sample`

```
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:

```

---

## `directory-to-markdown\.git\hooks\pre-push.sample`

```
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0

```

---

## `directory-to-markdown\.git\hooks\pre-rebase.sample`

```
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END

```

---

## `directory-to-markdown\.git\hooks\pre-receive.sample`

```
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi

```

---

## `directory-to-markdown\.git\hooks\prepare-commit-msg.sample`

```
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi

```

---

## `directory-to-markdown\.git\hooks\push-to-checkout.sample`

```
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi

```

---

## `directory-to-markdown\.git\hooks\sendemail-validate.sample`

```
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi

```

---

## `directory-to-markdown\.git\hooks\update.sample`

```
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0

```

---

## `directory-to-markdown\.git\index`

_[Skipped binary file: application/octet-stream]_

---

## `directory-to-markdown\.git\info\exclude`

```
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~

```

---

## `directory-to-markdown\.git\logs\HEAD`

```
0000000000000000000000000000000000000000 5fe875f67e63eaced0b9bff4ece9099534512cdd draysams <rsamdavies@gmail.com> 1753526379 +0100	clone: from https://github.com/draysams/directory-to-markdown.git

```

---

## `directory-to-markdown\.git\logs\refs\heads\main`

```
0000000000000000000000000000000000000000 5fe875f67e63eaced0b9bff4ece9099534512cdd draysams <rsamdavies@gmail.com> 1753526379 +0100	clone: from https://github.com/draysams/directory-to-markdown.git

```

---

## `directory-to-markdown\.git\logs\refs\remotes\origin\HEAD`

```
0000000000000000000000000000000000000000 5fe875f67e63eaced0b9bff4ece9099534512cdd draysams <rsamdavies@gmail.com> 1753526379 +0100	clone: from https://github.com/draysams/directory-to-markdown.git

```

---

## `directory-to-markdown\.git\objects\pack\pack-cd8f8e77debfd3e65e9ced825ab1f8e67c97b0ae.idx`

_[Skipped binary file: application/octet-stream]_

---

## `directory-to-markdown\.git\objects\pack\pack-cd8f8e77debfd3e65e9ced825ab1f8e67c97b0ae.pack`

_[Skipped binary file: application/octet-stream]_

---

## `directory-to-markdown\.git\objects\pack\pack-cd8f8e77debfd3e65e9ced825ab1f8e67c97b0ae.rev`

_[Skipped binary file: application/octet-stream]_

---

## `directory-to-markdown\.git\packed-refs`

```
# pack-refs with: peeled fully-peeled sorted 
5fe875f67e63eaced0b9bff4ece9099534512cdd refs/remotes/origin/main
5fe875f67e63eaced0b9bff4ece9099534512cdd refs/tags/v1.0.0

```

---

## `directory-to-markdown\.git\refs\heads\main`

```
5fe875f67e63eaced0b9bff4ece9099534512cdd

```

---

## `directory-to-markdown\.git\refs\remotes\origin\HEAD`

```
ref: refs/remotes/origin/main

```

---

## `directory-to-markdown\.github\workflows\go.yml`

```
name: Go

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
      - name: Run tests with coverage
        run: |
          go test ./... -coverprofile=coverage.out
      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage.out 
```

---

## `directory-to-markdown\.gitignore`

```
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool
*.out
cmd/directory-to-markdown/*.md

# Go workspace file
go.work

# OS-specific files
.DS_Store
Thumbs.db

# Ignore the compiled binary in the project root ONLY.
# This prevents conflicts with source directories of the same name.
/directory-to-markdown
/directory-to


```

---

## `directory-to-markdown\Makefile`

```
# Go project automation
.PHONY: test coverage

test:
	go test ./... -cover

coverage:
	go test ./... -coverprofile=coverage.out
	go tool cover -html=coverage.out 
```

---

## `directory-to-markdown\README.md`

```
# Directory-to-Markdown

[![Go Report Card](https://goreportcard.com/badge/github.com/draysams/directory-to-markdown)](https://goreportcard.com/report/github.com/draysams/directory-to-markdown)
[![Go.Dev reference](https://img.shields.io/badge/go.dev-reference-blue?logo=go&logoColor=white)](https://pkg.go.dev/github.com/draysams/directory-to-markdown)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

A powerful and simple Go CLI tool to instantly convert an entire directory of code and text files into a single, structured Markdown document.

This tool recursively scans a folder, preserves the file structure as headers, and intelligently skips binary files, making it perfect for codebase analysis, documentation, and more.

---


### Key Use Cases

This tool is especially useful for:

*   **ü§ñ AI Code Analysis:** Feed your entire codebase to Large Language Models (LLMs) like GPT-4 or Claude in a single, clean prompt.
*   **üìö Technical Documentation:** Quickly generate a single-file version of a project's source code for easy reading or distribution.
*   **üóÑÔ∏è Code Archiving:** Create a simple, human-readable snapshot of your project at a specific point in time.
*   **üß† Knowledge Base Creation:** Consolidate a folder full of notes and scripts into one master document.

### Features

*   **Recursive Traversal**: Automatically scans all subdirectories to capture every file.
*   **Intelligent Binary Skipping**: Detects and skips binary files (images, executables) while still listing them, preventing gibberish output.
*   **Preserves File Structure**: Represents the directory hierarchy with clear Markdown headers.
*   **Code-Friendly Fencing**: Wraps all file content in Markdown code blocks for proper syntax highlighting and formatting.
*   **Automatic Naming**: Generates a sensible output filename by default (e.g., `my-project_snapshot.md`).
*   **Cross-Platform**: Built with Go, it's a single, fast executable that runs on Windows, macOS, and Linux with no dependencies.

---

### Installation

#### Option 1: From a Release (Recommended)

1.  Go to the [**Releases**](https://github.com/draysams/directory-to-markdown/releases) page of this repository.
2.  Download the archive for your operating system (e.g., `directory-to-markdown_1.0.0_Linux_x86_64.tar.gz`).
3.  Extract the `directory-to-markdown` binary.
4.  Move the binary to a location in your system's `PATH` to make it runnable from anywhere.
    ```bash
    # For Linux/macOS
    sudo mv directory-to-markdown /usr/local/bin/
    ```

#### Option 2: From Source

This requires a working [Go environment](https://go.dev/doc/install).

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/draysams/directory-to-markdown.git
    cd directory-to-markdown
    ```

2.  **Build and install:**
    ```bash
    go install ./cmd/directory-to-markdown
    ```
    This will compile the binary and place it in your Go bin directory (`$GOPATH/bin`).

---

### Usage

The tool is designed to be simple and intuitive.

#### Basic Command

To process the current directory, simply run the command from within that directory.

```bash
# On Linux/macOS, if installed to PATH
directory-to-markdown .
```
```bash
# If running the binary directly in the current folder
./directory-to-markdown .
```

This will create a new file in your current directory named `your-folder-name_snapshot.md.`

Example:

If you are in a folder named `my-api`, running the command will produce:
```
‚úÖ Successfully created snapshot: my-api_snapshot.md
```

### Processing a Different Directory

You can specify the path to any directory you want to process.

```
directory-to-markdown /path/to/my/project
```

This will create `project_snapshot.md` in your current directory.

### Specifying a Custom Output File

Use the `--output` or `-o` flag to set a custom name and location for the output file.

```bash
directory-to-markdown . --output my-code-snapshot.md
```

# Or using the shorthand
```bash
directory-to-markdown . -o docs/archive.md
```
This will save the output to the specified file.

---

### Contributing

Contributions are welcome! Whether it's reporting a bug, suggesting a feature, or submitting a pull request, all help is appreciated.


### License

This project is licensed under the MIT License. See the [**LICENSE**](LICENSE) file for details.
```

---

## `directory-to-markdown\cmd\directory-to-markdown\main.go`

```
package main

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/draysams/directory-to-markdown/internal/processor"
	"github.com/spf13/cobra"
)

func newRootCmd() *cobra.Command {
	var outputFilename string

	cmd := &cobra.Command{
		Use:   "directory-to-markdown [directory]",
		Short: "A CLI tool to concatenate file contents into a single markdown document.",
		Long: `directory-to-markdown is a command-line tool that traverses a specified folder directory,
copies the contents of each text file, and appends them into a single markdown document.
It preserves the file structure and skips binary files.`,
		Args: cobra.ExactArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			dir := args[0]

			markdown, err := processor.ProcessDirectory(dir)
			if err != nil {
				cmd.PrintErrf("Error processing directory: %v\n", err)
				os.Exit(1)
			}

			if outputFilename == "" {
				dirName := filepath.Base(dir)
				outputFilename = fmt.Sprintf("%s_snapshot.md", dirName)
			}

			err = os.WriteFile(outputFilename, []byte(markdown), 0644)
			if err != nil {
				cmd.PrintErrf("Error writing to file: %v\n", err)
				os.Exit(1)
			}

			cmd.Printf(" F5F Successfully created snapshot: %s\n", outputFilename)
		},
	}

	cmd.PersistentFlags().StringVarP(&outputFilename, "output", "o", "", "Specify a custom output file name (optional)")

	return cmd
}

func main() {
	cmd := newRootCmd()
	if err := cmd.Execute(); err != nil {
		os.Exit(1)
	}
}

```

---

## `directory-to-markdown\cmd\directory-to-markdown\main_test.go`

```
package main

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func setupTestDir(t *testing.T) (string, string) {
	t.Helper()

	tmpDir := t.TempDir()
	testContent := "hello from test file"
	testFilePath := filepath.Join(tmpDir, "test.txt")

	if err := os.WriteFile(testFilePath, []byte(testContent), 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	return tmpDir, testContent
}

func TestRootCmd(t *testing.T) {
	t.Run("Default Output", func(t *testing.T) {
		tmpDir, testContent := setupTestDir(t)

		runDir := t.TempDir()
		if err := os.Chdir(runDir); err != nil {
			t.Fatalf("Failed to change directory: %v", err)
		}

		cmd := newRootCmd()
		var out bytes.Buffer
		cmd.SetOut(&out)

		expectedOutputFile := filepath.Join(runDir, filepath.Base(tmpDir)+"_snapshot.md")

		cmd.SetArgs([]string{tmpDir})
		if err := cmd.Execute(); err != nil {
			t.Fatalf("cmd.Execute() failed unexpectedly: %v", err)
		}

		if !strings.Contains(out.String(), "Successfully created snapshot") {
			t.Errorf("Expected success message was not printed to stdout. Got: %s", out.String())
		}

		outputBytes, err := os.ReadFile(expectedOutputFile)
		if err != nil {
			t.Fatalf("Failed to read expected output file %q: %v", expectedOutputFile, err)
		}
		if !strings.Contains(string(outputBytes), testContent) {
			t.Error("Output file is missing expected content.")
		}
	})

	t.Run("Custom Output with Flag", func(t *testing.T) {
		tmpDir, testContent := setupTestDir(t)
		runDir := t.TempDir()

		customOutputFile := filepath.Join(runDir, "my_custom_snapshot.md")

		cmd := newRootCmd()
		cmd.SetArgs([]string{tmpDir, "-o", customOutputFile})
		if err := cmd.Execute(); err != nil {
			t.Fatalf("cmd.Execute() with -o flag failed: %v", err)
		}

		outputBytes, err := os.ReadFile(customOutputFile)
		if err != nil {
			t.Fatalf("Failed to read custom output file %q: %v", customOutputFile, err)
		}
		if !strings.Contains(string(outputBytes), testContent) {
			t.Error("Custom output file is missing expected content.")
		}
	})

	t.Run("No Arguments Error", func(t *testing.T) {
		cmd := newRootCmd()
		cmd.SetArgs([]string{})

		err := cmd.Execute()
		if err == nil {
			t.Error("Expected an error when running with no arguments, but got nil")
		}
	})
}

```

---

## `directory-to-markdown\go.mod`

```
module github.com/draysams/directory-to-markdown

go 1.24.0

require github.com/spf13/cobra v1.9.1

require (
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/spf13/pflag v1.0.7 // indirect
)

```

---

## `directory-to-markdown\go.sum`

```
github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
github.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=
github.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/spf13/cobra v1.9.1 h1:CXSaggrXdbHK9CF+8ywj8Amf7PBRmPCOJugH954Nnlo=
github.com/spf13/cobra v1.9.1/go.mod h1:nDyEzZ8ogv936Cinf6g1RU9MRY64Ir93oCnqb9wxYW0=
github.com/spf13/pflag v1.0.6/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/spf13/pflag v1.0.7 h1:vN6T9TfwStFPFM5XzjsvmzZkLuaLX+HS+0SeFLRgU6M=
github.com/spf13/pflag v1.0.7/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=

```

---

## `directory-to-markdown\internal\processor\processor.go`

```
package processor

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

// Returns a markdown snapshot of the directory, skipping binary files to avoid unreadable output.
func ProcessDirectory(rootDir string) (string, error) {
	var markdownContent strings.Builder

	markdownContent.WriteString(fmt.Sprintf("# Project Snapshot: %s\n\n", filepath.Base(rootDir)))

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			return nil
		}

		relPath, err := filepath.Rel(rootDir, path)
		if err != nil {
			return err
		}

		content, err := os.ReadFile(path)
		if err != nil {
			// Log the error but continue processing other files, so a single unreadable file doesn't stop the snapshot.
			fmt.Fprintf(os.Stderr, "Warning: Could not read file %s: %v\n", path, err)
			return nil
		}

		contentType := http.DetectContentType(content)

		markdownContent.WriteString(fmt.Sprintf("## `%s`\n\n", relPath))

		if strings.HasPrefix(contentType, "text/") {
			markdownContent.WriteString("```\n")
			markdownContent.Write(content)
			markdownContent.WriteString("\n```\n\n")
		} else {
			// Avoid dumping binary data into markdown, which would be unreadable.
			markdownContent.WriteString(fmt.Sprintf("_[Skipped binary file: %s]_\n\n", contentType))
		}

		markdownContent.WriteString("---\n\n")

		return nil
	})

	if err != nil {
		return "", err
	}

	return markdownContent.String(), nil
}

```

---

## `directory-to-markdown\internal\processor\processor_test.go`

```
package processor

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestProcessDirectory(t *testing.T) {
	t.Run("Standard Directory Processing", func(t *testing.T) {
		tmpDir := t.TempDir()

		subDir := filepath.Join(tmpDir, "subdir")
		if err := os.Mkdir(subDir, 0755); err != nil {
			t.Fatalf("Failed to create subdirectory: %v", err)
		}

		file1Content := "hello from file1"
		file2Content := "content from subdir"
		if err := os.WriteFile(filepath.Join(tmpDir, "file1.txt"), []byte(file1Content), 0644); err != nil {
			t.Fatalf("Failed to write to file1.txt: %v", err)
		}
		if err := os.WriteFile(filepath.Join(subDir, "file2.log"), []byte(file2Content), 0644); err != nil {
			t.Fatalf("Failed to write to file2.log: %v", err)
		}

		markdown, err := ProcessDirectory(tmpDir)
		if err != nil {
			t.Fatalf("ProcessDirectory returned an unexpected error: %v", err)
		}

		expectedProjectHeader := "# Project Snapshot: " + filepath.Base(tmpDir)
		if !strings.Contains(markdown, expectedProjectHeader) {
			t.Errorf("Expected markdown to contain project header %q, but it was not found", expectedProjectHeader)
		}

		expectedFile1Header := "## `file1.txt`"
		if !strings.Contains(markdown, expectedFile1Header) {
			t.Errorf("Expected markdown to contain file header %q", expectedFile1Header)
		}
		if !strings.Contains(markdown, file1Content) {
			t.Errorf("Expected markdown to contain content of file1.txt")
		}

		expectedFile2Header := "## `" + filepath.Join("subdir", "file2.log") + "`"
		if !strings.Contains(markdown, expectedFile2Header) {
			t.Errorf("Expected markdown to contain file header %q for nested file", expectedFile2Header)
		}
		if !strings.Contains(markdown, file2Content) {
			t.Errorf("Expected markdown to contain content of file2.log")
		}
	})

	t.Run("Binary File Skipping", func(t *testing.T) {
		tmpDir := t.TempDir()

		textFileContent := "this is a text file"
		if err := os.WriteFile(filepath.Join(tmpDir, "readme.txt"), []byte(textFileContent), 0644); err != nil {
			t.Fatalf("Failed to write to readme.txt: %v", err)
		}

		binaryFileContent := []byte{0xDE, 0xAD, 0xBE, 0xEF, 0x00, 0xFF}
		if err := os.WriteFile(filepath.Join(tmpDir, "a.out"), binaryFileContent, 0644); err != nil {
			t.Fatalf("Failed to write to a.out: %v", err)
		}

		markdown, err := ProcessDirectory(tmpDir)
		if err != nil {
			t.Fatalf("ProcessDirectory returned an unexpected error: %v", err)
		}

		if !strings.Contains(markdown, textFileContent) {
			t.Error("Markdown output is missing the content of the text file.")
		}

		if strings.Contains(markdown, string(binaryFileContent)) {
			t.Error("Markdown output incorrectly contains the content of the binary file.")
		}

		expectedSkipMessage := "_[Skipped binary file: application/octet-stream]_"
		if !strings.Contains(markdown, expectedSkipMessage) {
			t.Errorf("Expected markdown to contain the skip message %q, but it was not found", expectedSkipMessage)
		}

		expectedBinaryHeader := "## `a.out`"
		if !strings.Contains(markdown, expectedBinaryHeader) {
			t.Errorf("Expected markdown to contain the header for the binary file %q", expectedBinaryHeader)
		}
	})

	t.Run("Empty Directory", func(t *testing.T) {
		tmpDir := t.TempDir()

		markdown, err := ProcessDirectory(tmpDir)
		if err != nil {
			t.Fatalf("ProcessDirectory returned an unexpected error: %v", err)
		}

		expectedProjectHeader := "# Project Snapshot: " + filepath.Base(tmpDir)
		expectedOutput := expectedProjectHeader + "\n\n"

		if markdown != expectedOutput {
			t.Errorf("Expected markdown for empty directory to be exactly %q, but got %q", expectedOutput, markdown)
		}
	})
}

```

---

## `dtos\__init__.py`

```

```

---

## `dtos\__pycache__\__init__.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `dtos\__pycache__\session_dtos.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `dtos\session_dtos.py`

```
# rw_backend/dtos/session_dtos.py

from rw_backend.database.models import Session, Lap, Stint

# --- Helper Functions ---

def _format_time_from_seconds(seconds: float | None) -> str | None:
    """Converts seconds into a MM:SS.mmm format string."""
    if seconds is None or seconds <= 0:
        return None
    minutes = int(seconds // 60)
    remaining_seconds = seconds % 60
    return f"{minutes}:{remaining_seconds:06.3f}"

# --- Mappers ---

def map_session_to_summary_dto(session: Session) -> dict:
    """
    Maps a Session database model to the SessionSummary DTO structure
    expected by the frontend.
    """
    laps = list(Lap.select().join(Stint).where(Stint.session == session))
    valid_laps = [lap for lap in laps if lap.is_valid]

    best_lap_s = min((lap.lap_time for lap in valid_laps), default=None)
    average_lap_s = (sum(lap.lap_time for lap in valid_laps) / len(valid_laps)) if valid_laps else None

    duration_s = (session.ended_at - session.started_at).total_seconds() if session.ended_at else 0

    return {
        "id": session.id,
        "simulator": "lmu",
        "track": session.track_name,
        "car": session.car_model,
        "sessionType": session.session_type,
        "date": session.started_at.isoformat(),
        "dateEnded": session.ended_at.isoformat() if session.ended_at else None,
        "duration": _format_time_from_seconds(duration_s) or "0:00.000",
        "durationMs": duration_s * 1000,
        "bestLap": _format_time_from_seconds(best_lap_s),
        "bestLapMs": best_lap_s * 1000 if best_lap_s else None,
        "averageLap": _format_time_from_seconds(average_lap_s),
        "averageLapMs": average_lap_s * 1000 if average_lap_s else None,
        "totalLaps": len(laps),
        "validLaps": len(valid_laps),
        "distance": 0.0,
        "fuelUsed": 0.0,
        "weather": "Clear",
        "trackTemp": session.track_temp,
        "airTemp": session.air_temp,
    }

def map_lap_to_detail_dto(lap: Lap) -> dict:
    """
    Maps a Lap database model to the LapData DTO structure
    expected by the frontend.
    """
    return {
        "lapNumber": lap.lap_number,
        "lapTime": _format_time_from_seconds(lap.lap_time),
        "lapTimeMs": lap.lap_time * 1000,
        "sector1": _format_time_from_seconds(lap.sector1_time),
        "sector1Ms": lap.sector1_time * 1000 if lap.sector1_time else 0,
        "sector2": _format_time_from_seconds(lap.sector2_time),
        "sector2Ms": lap.sector2_time * 1000 if lap.sector2_time else 0,
        "sector3": _format_time_from_seconds(lap.sector3_time),
        "sector3Ms": lap.sector3_time * 1000 if lap.sector3_time else 0,
        "isValid": lap.is_valid,
        "delta": 0,
        "fuelUsed": 0,
        "tyrePressure": {"fl": 0, "fr": 0, "rl": 0, "rr": 0},
        "speed": {"sector1": 0, "sector2": 0, "sector3": 0, "topSpeed": 0},
    }
```

---

## `generators\__init__.py`

```

```

---

## `generators\__pycache__\__init__.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `generators\__pycache__\event_generator.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `generators\event_generator.py`

```
# rw_backend/generators/event_generator.py

import threading
from queue import Queue
from rw_backend.core.events import (
    SessionStarted, SessionEnded, StintStarted, StintEnded, LapCompleted, TelemetryUpdate
)

# --- Helper functions ---
def Cbytestring2Python(bytestring):
    try: return bytes(bytestring).partition(b'\0')[0].decode('utf-8').strip()
    except: return ""

def map_game_phase_to_session_type(game_phase: int) -> str:
    phases = { 5: "Practice", 6: "Qualifying", 7: "Warmup", 8: "Race" }
    return phases.get(game_phase, "Unknown")

class EventGenerator(threading.Thread):
    """
    The brain of the daemon. Consumes raw data and produces high-level events
    using a robust, state-first processing order.
    """
    def __init__(self, raw_data_queue: Queue, event_queue: Queue):
        super().__init__(daemon=True)
        self.raw_data_queue = raw_data_queue
        self.event_queue = event_queue
        self._running = threading.Event()
        # State Tracking
        self.last_extended_data = {}
        self.last_player_data = {}
        self.player_state = "UNKNOWN" # ON_TRACK, IN_PITS, IN_GARAGE

# In rw_backend/generators/event_generator.py, inside the EventGenerator class:

    def run(self):
        print("[Event Generator] Thread started.", flush=True)
        self._running.set()
        while self._running.is_set():
            raw_data = self.raw_data_queue.get()
            if raw_data is None: break

            extended = raw_data.get('extended')
            
            # --- 1. SESSION DETECTION ---
            self.detect_session_events(raw_data)
            
            if not extended.mSessionStarted:
                self.last_extended_data = {field[0]: getattr(extended, field[0]) for field in extended._fields_}
                continue

            # --- 2. DATA VALIDATION ---
            scoring = raw_data.get('scoring')
            telemetry = raw_data.get('telemetry') # Get telemetry here
            player_scoring = next((v for v in scoring.mVehicles if v.mIsPlayer), None) if scoring else None
            
            if not telemetry or not player_scoring:
                self.last_extended_data = {field[0]: getattr(extended, field[0]) for field in extended._fields_}
                continue

            # --- 3. EMIT TELEMETRY UPDATE EVENT (NEW) ---
            # On every valid frame while in a session, emit an event with the raw data.
            # The LiveDataHandler will be responsible for formatting this.
            self.event_queue.put(TelemetryUpdate(payload=raw_data))

            # --- 4. DETECT DISCRETE EVENTS ---
            self.detect_lap_events(player_scoring)
            self.detect_stint_events(player_scoring, extended)

            # --- 5. UPDATE STATE FOR NEXT FRAME ---
            self.last_player_data = {field[0]: getattr(player_scoring, field[0]) for field in player_scoring._fields_}
            self.last_extended_data = {field[0]: getattr(extended, field[0]) for field in extended._fields_}

    def detect_session_events(self, raw_data):
        extended = raw_data.get('extended')
        was_session_started = self.last_extended_data.get('mSessionStarted', False)
        
        # Transition TO a started session
        if extended.mSessionStarted and not was_session_started:
            scoring = raw_data.get('scoring')
            telemetry = raw_data.get('telemetry')
            scoring_info = scoring.mScoringInfo
            player_scoring = next((v for v in scoring.mVehicles if v.mIsPlayer), None)
            
            if scoring_info and player_scoring and telemetry:
                uid = f"{Cbytestring2Python(scoring_info.mTrackName)}-{scoring_info.mSession}"
                event = SessionStarted(
                    uid=uid, track_name=Cbytestring2Python(scoring_info.mTrackName),
                    session_type=map_game_phase_to_session_type(scoring_info.mGamePhase),
                    player_name=Cbytestring2Python(player_scoring.mDriverName),
                    car_model=Cbytestring2Python(telemetry.mVehicleName),
                    car_class=Cbytestring2Python(player_scoring.mVehicleClass),
                    track_temp=scoring_info.mTrackTemp, air_temp=scoring_info.mAmbientTemp
                )
                self.event_queue.put(event)
                self.player_state = "IN_GARAGE"

        # Transition FROM a started session
        if not extended.mSessionStarted and was_session_started:
            self.event_queue.put(SessionEnded())
            self.player_state = "UNKNOWN"

    def detect_stint_events(self, player_scoring, extended):
        # Determine the player's current physical state with corrected priority
        if player_scoring.mInGarageStall:
            new_state = "IN_GARAGE"
        elif player_scoring.mInPits:
            new_state = "IN_PITS"
        else:
            new_state = "ON_TRACK"
        
        if new_state != self.player_state:
            if new_state == "ON_TRACK" and self.player_state in ["IN_PITS", "IN_GARAGE"]:
                self.event_queue.put(StintStarted(lap_number=player_scoring.mTotalLaps))
            elif new_state in ["IN_PITS", "IN_GARAGE"] and self.player_state == "ON_TRACK":
                self.event_queue.put(StintEnded(lap_number=player_scoring.mTotalLaps))
            self.player_state = new_state

    def detect_lap_events(self, player_scoring):
        current_laps = player_scoring.mTotalLaps
        last_laps = self.last_player_data.get('mTotalLaps', -1)

        # Trigger is the increment of the lap counter
        if current_laps > last_laps:
            # Data for the completed lap is in the PREVIOUS frame's data
            prev_data = self.last_player_data
            if prev_data:
                lap_time = prev_data.get('mLastLapTime', -1.0)
                lap_num_to_log = prev_data.get('mTotalLaps', current_laps)
                
                event = LapCompleted(
                    lap_number=lap_num_to_log,
                    lap_time=lap_time,
                    sector1_time=prev_data.get('mLastSector1', -1.0),
                    sector2_time=prev_data.get('mLastSector2', -1.0) - prev_data.get('mLastSector1', 0),
                    sector3_time=lap_time - prev_data.get('mLastSector2', 0),
                    is_valid=(prev_data.get('mCountLapFlag') == 2)
                )
                self.event_queue.put(event)

    def stop(self):
        self._running.clear()
        self.raw_data_queue.put(None)
```

---

## `handlers\__init__.py`

```

```

---

## `handlers\__pycache__\__init__.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `handlers\__pycache__\lap_handler.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `handlers\__pycache__\live_data_handler.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `handlers\__pycache__\session_handler.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `handlers\__pycache__\stint_handler.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `handlers\lap_handler.py`

```
# rw_backend/handlers/lap_handler.py

from datetime import datetime
from rw_backend.core.events import LapCompleted
from rw_backend.database.models import Lap

def format_time_from_seconds(seconds: float | None) -> str | None:
        if seconds is None or seconds <= 0: return None
        minutes = int(seconds // 60)
        remaining_seconds = seconds % 60
        return f"{minutes}:{remaining_seconds:06.3f}"

class LapHandler:
    def __init__(self, stint_handler):
        self.stint_handler = stint_handler

    def handle_event(self, event):
        if isinstance(event, LapCompleted):
            self.on_lap_completed(event)

    def on_lap_completed(self, event: LapCompleted):
        stint = self.stint_handler.current_stint_model
        if not stint:
            print("[LapHandler] WARNING: Received LapCompleted but no active stint.", flush=True)
            return
            
        print(f"[LapHandler] Saving Lap #{event.lap_number} to database.", flush=True)
        Lap.create(
            stint=stint, lap_number=event.lap_number, lap_time=event.lap_time,
            sector1_time=event.sector1_time, sector2_time=event.sector2_time,
            sector3_time=event.sector3_time, is_valid=event.is_valid,
            timestamp=datetime.now()
        )

    # Add this formatting method
    def format_lap_for_ui(self, event: LapCompleted) -> dict:
        return { 
            "lapNumber": event.lap_number, 
            "lapTime": format_time_from_seconds(event.lap_time),
            "lapTimeMs": event.lap_time * 1000 if event.lap_time > 0 else 0,
            "sector1": format_time_from_seconds(event.sector1_time),
            "sector1Ms": (event.sector1_time or 0) * 1000,
            "sector2": format_time_from_seconds(event.sector2_time),
            "sector2Ms": (event.sector2_time or 0) * 1000,
            "sector3": format_time_from_seconds(event.sector3_time),
            "sector3Ms": (event.sector3_time or 0) * 1000,
            "isValid": event.is_valid, 
            "delta": 0, "fuelUsed": 0, "tyrePressure": {}, "speed": {} 
        }
```

---

## `handlers\live_data_handler.py`

```
# rw_backend/handlers/live_data_handler.py

import math
from rw_backend.core.events import TelemetryUpdate, LapCompleted
from rw_backend.core.live_data_server import LiveDataServer

# --- Helper functions ---
def Cbytestring2Python(bytestring):
    try: return bytes(bytestring).partition(b'\0')[0].decode('utf-8').strip()
    except: return ""

def map_game_phase_to_session_type(game_phase: int) -> str:
    phases = { 5: "Practice", 6: "Qualifying", 7: "Warmup", 8: "Race" }
    return phases.get(game_phase, "Unknown")

def format_time_from_seconds(seconds: float | None) -> str | None:
    if seconds is None or seconds <= 0: return None
    minutes = int(seconds // 60)
    remaining_seconds = seconds % 60
    return f"{minutes}:{remaining_seconds:06.3f}"

class LiveDataHandler:
    """
    Handles events related to live data and pushes formatted
    payloads to the WebSocket server for the UI.
    """
    def __init__(self, server: LiveDataServer, session_handler, lap_handler):
        self.server = server
        self.session_handler = session_handler
        self.lap_handler = lap_handler
        self.last_lap_object_sent = None

    def handle_event(self, event):
        if isinstance(event, TelemetryUpdate):
            self.on_telemetry_update(event)
        elif isinstance(event, LapCompleted):
            # When a lap is completed, we format it and store it to be sent
            # with the next telemetry update.
            # We access the format_lap_for_ui method which should be part of LapHandler
            self.last_lap_object_sent = self.lap_handler.format_lap_for_ui(event)

    def on_telemetry_update(self, event: TelemetryUpdate):
        raw_data = event.payload
        telemetry = raw_data.get('telemetry')
        scoring = raw_data.get('scoring')
        
        # --- THE FIX: ADD THIS VALIDATION BLOCK ---
        # If we are not in a session, scoring_info will be None.
        # This guard clause prevents the handler from crashing the daemon.
        scoring_info = scoring.mScoringInfo if scoring else None
        if not scoring_info or not telemetry:
            # Optionally, send a "disconnected" or "in menus" status to the UI
            # For now, we just safely exit.
            return
        # --- END OF FIX ---

        player_scoring = next((v for v in scoring.mVehicles if v.mIsPlayer), None)
        if not player_scoring: return

        vel = telemetry.mLocalVel
        speed_ms = math.sqrt(vel.x**2 + vel.y**2 + vel.z**2)
        
        session_id = self.session_handler.current_session_model.id if self.session_handler.current_session_model else -1

        live_data = {
            "sessionId": session_id,
            "isConnected": True,
            "sessionType": map_game_phase_to_session_type(scoring_info.mGamePhase),
            "track": Cbytestring2Python(scoring_info.mTrackName),
            "car": Cbytestring2Python(telemetry.mVehicleName),
            "currentLap": player_scoring.mTotalLaps + 1,
            "position": player_scoring.mPlace,
            "fuelLevel": telemetry.mFuel,
            "tyrePressures": {
                "frontLeft": telemetry.mWheels[0].mPressure, "frontRight": telemetry.mWheels[1].mPressure,
                "rearLeft": telemetry.mWheels[2].mPressure, "rearRight": telemetry.mWheels[3].mPressure,
            },
            "trackTemp": scoring_info.mTrackTemp,
            "airTemp": scoring_info.mAmbientTemp,
            "sessionTimeRemaining": scoring_info.mEndET - scoring_info.mCurrentET,
            "bestLapTime": format_time_from_seconds(player_scoring.mBestLapTime),
            "lastLap": self.last_lap_object_sent,
        }
        
        self.server.push_data(live_data)
        
        if self.last_lap_object_sent:
            self.last_lap_object_sent = None
```

---

## `handlers\session_handler.py`

```
# rw_backend/handlers/session_handler.py

from datetime import datetime
from rw_backend.core.events import SessionStarted, SessionEnded
from rw_backend.database.models import Session

class SessionHandler:
    """Handles session-related events to manage the database."""
    def __init__(self):
        self.current_session_model = None
        # On startup, we don't need to resume here. The event generator will
        # compare against the DB and only fire a SessionStarted event if it's new.
        
    def handle_event(self, event):
        if isinstance(event, SessionStarted):
            self.on_session_started(event)
        elif isinstance(event, SessionEnded):
            self.on_session_ended(event)

    def on_session_started(self, event: SessionStarted):
        print(f"[SessionHandler] Received SessionStarted event for UID: {event.uid}", flush=True)
        # Check if this session already exists from a previous run (resumption case)
        session, created = Session.get_or_create(
            game_session_uid=event.uid,
            defaults={
                'track_name': event.track_name,
                'session_type': event.session_type,
                'player_name': event.player_name,
                'car_model': event.car_model,
                'car_class': event.car_class,
                'started_at': datetime.now(),
                'track_temp': event.track_temp,
                'air_temp': event.air_temp
            }
        )
        if created:
            print(f"[SessionHandler] Created new Session #{session.id} in the database.", flush=True)
        else:
            print(f"[SessionHandler] Resumed existing Session #{session.id} from the database.", flush=True)
        
        self.current_session_model = session
        return session

    def on_session_ended(self, event: SessionEnded):
        if self.current_session_model:
            print(f"[SessionHandler] Received SessionEnded event. Closing session #{self.current_session_model.id}", flush=True)
            self.current_session_model.ended_at = datetime.now()
            self.current_session_model.save()
            self.current_session_model = None
```

---

## `handlers\stint_handler.py`

```
# rw_backend/handlers/stint_handler.py

from rw_backend.core.events import StintStarted, StintEnded, SessionStarted, SessionEnded
from rw_backend.database.models import Stint

class StintHandler:
    """Handles stint-related events to manage the database."""
    def __init__(self, session_handler):
        self.session_handler = session_handler
        self.current_stint_model = None

    def handle_event(self, event):
        if isinstance(event, SessionStarted):
            # When a new session starts, reset our stint state
            self.current_stint_model = None
        elif isinstance(event, StintStarted):
            self.on_stint_started(event)
        elif isinstance(event, StintEnded):
            self.on_stint_ended(event)
        elif isinstance(event, SessionEnded):
            self.on_session_ended()

    def on_stint_started(self, event: StintStarted):
        session = self.session_handler.current_session_model
        if not session:
            print("[StintHandler] WARNING: Received StintStarted but no active session.", flush=True)
            return

        stint_num = 1
        last_stint = Stint.select().where(Stint.session == session).order_by(Stint.stint_number.desc()).first()
        if last_stint:
            stint_num = last_stint.stint_number + 1
        
        print(f"[StintHandler] Starting Stint #{stint_num}", flush=True)
        self.current_stint_model = Stint.create(
            session=session,
            stint_number=stint_num,
            started_on_lap=event.lap_number
        )

    def on_stint_ended(self, event: StintEnded):
        if self.current_stint_model:
            print(f"[StintHandler] Ending Stint #{self.current_stint_model.stint_number}", flush=True)
            self.current_stint_model.ended_on_lap = event.lap_number
            self.current_stint_model.save()
            self.current_stint_model = None
            
    def on_session_ended(self):
        """Ensure the final stint is closed when the session ends."""
        if self.current_stint_model and self.current_stint_model.ended_on_lap is None:
            print("[StintHandler] Session ended, closing final open stint.", flush=True)
            self.on_stint_ended(StintEnded(lap_number=0)) # Lap number doesn't matter here```
```

---

## `pyRfactor2SharedMemory\.github\workflows\pythonapp.yml`

```
# This workflow will install Python dependencies, run tests and lint with a single version of Python
# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions

name: Python application

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up Python 3.7
      uses: actions/setup-python@v1
      with:
        python-version: 3.7
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Lint with flake8
      run: |
        pip install flake8
        # stop the build if there are Python syntax errors or undefined names
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    #- name: Test with pytest
    #  run: |
    #    pip install pytest
    #    pytest

```

---

## `pyRfactor2SharedMemory\.gitignore`

```
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUNIT
*.VisualState.xml
TestResult.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# JustCode is a .NET coding add-in
.JustCode

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- Backup*.rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# JetBrains Rider
.idea/
*.sln.iml

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# BeatPulse healthcheck temp database
healthchecksdb
/env
*.pyo
/pylint

```

---

## `pyRfactor2SharedMemory\.gitmodules`

```
[submodule "hpp2py"]
	path = hpp2py
	url = https://github.com/TonyWhitley/hpp2py

```

---

## `pyRfactor2SharedMemory\.pylintrc`

```
[MASTER]

# A comma-separated list of package or module names from where C extensions may
# be loaded. Extensions are loading into the active Python interpreter and may
# run arbitrary code.
extension-pkg-whitelist=

# Add files or directories to the blacklist. They should be base names, not
# paths.
ignore=CVS,pyDirectInputKeySend,pyRfactor2SharedMemory,WindowsVersionFile,env,pylint

# Add files or directories matching the regex patterns to the blacklist. The
# regex matches against base names, not paths.
ignore-patterns=pyDirectInputKeySend,pyRfactor2SharedMemory,WindowsVersionFile

# Python code to execute, usually for sys.path manipulation such as
# pygtk.require().
#init-hook=

# Use multiple processes to speed up Pylint. Specifying 0 will auto-detect the
# number of processors available to use.
jobs=1

# Control the amount of potential inferred values when inferring a single
# object. This can help the performance when dealing with large functions or
# complex, nested conditions.
limit-inference-results=100

# List of plugins (as comma separated values of python modules names) to load,
# usually to register additional checkers.
load-plugins=

# Pickle collected data for later comparisons.
persistent=yes

# Specify a configuration file.
#rcfile=

# When enabled, pylint would attempt to guess common misconfiguration and emit
# user-friendly hints instead of false-positive error messages.
suggestion-mode=yes

# Allow loading of arbitrary C extensions. Extensions are imported into the
# active Python interpreter and may run arbitrary code.
unsafe-load-any-extension=no


[MESSAGES CONTROL]

# Only show warnings with the listed confidence levels. Leave empty to show
# all. Valid levels: HIGH, INFERENCE, INFERENCE_FAILURE, UNDEFINED.
confidence=

# Disable the message, report, category or checker with the given ident(s). You
# can either give multiple identifiers separated by comma (,) or put this
# option multiple times (only on the command line, not in the configuration
# file where it should appear only once). You can also use "--disable=all" to
# disable everything first and then reenable specific checks. For example, if
# you want to run only the similarities checker, you can use "--disable=all
# --enable=similarities". If you want to run only the classes checker, but have
# no Warning level messages displayed, use "--disable=all --enable=classes
# --disable=W".
disable=print-statement,
        parameter-unpacking,
        unpacking-in-except,
        old-raise-syntax,
        backtick,
        long-suffix,
        old-ne-operator,
        old-octal-literal,
        import-star-module-level,
        non-ascii-bytes-literal,
        raw-checker-failed,
        bad-inline-option,
        locally-disabled,
        file-ignored,
        suppressed-message,
        useless-suppression,
        deprecated-pragma,
        use-symbolic-message-instead,
        apply-builtin,
        basestring-builtin,
        buffer-builtin,
        cmp-builtin,
        coerce-builtin,
        execfile-builtin,
        file-builtin,
        long-builtin,
        raw_input-builtin,
        reduce-builtin,
        standarderror-builtin,
        unicode-builtin,
        xrange-builtin,
        coerce-method,
        delslice-method,
        getslice-method,
        setslice-method,
        no-absolute-import,
        old-division,
        dict-iter-method,
        dict-view-method,
        next-method-called,
        metaclass-assignment,
        indexing-exception,
        raising-string,
        reload-builtin,
        oct-method,
        hex-method,
        nonzero-method,
        cmp-method,
        input-builtin,
        round-builtin,
        intern-builtin,
        unichr-builtin,
        map-builtin-not-iterating,
        zip-builtin-not-iterating,
        range-builtin-not-iterating,
        filter-builtin-not-iterating,
        using-cmp-argument,
        eq-without-hash,
        div-method,
        idiv-method,
        rdiv-method,
        exception-message-attribute,
        invalid-str-codec,
        sys-max-int,
        bad-python3-import,
        deprecated-string-function,
        deprecated-str-translate-call,
        deprecated-itertools-function,
        deprecated-types-field,
        next-method-defined,
        dict-items-not-iterating,
        dict-keys-not-iterating,
        dict-values-not-iterating,
        deprecated-operator-function,
        deprecated-urllib-function,
        xreadlines-attribute,
        deprecated-sys-function,
        exception-escape,
        comprehension-escape,
        # tjw additions
        redefined-outer-name,
        unnecessary-pass,
        unused-wildcard-import,
        anomalous-backslash-in-string,
        broad-except


# Enable the message, report, category or checker with the given ident(s). You can
# either give multiple identifier separated by comma (,) or put this option
# multiple time (only on the command line, not in the configuration file where
# it should appear only once). See also the "--disable" option for examples.
enable=c-extension-no-member


[REPORTS]

# Python expression which should return a note less than 10 (10 is the highest
# note). You have access to the variables errors warning, statement which
# respectively contain the number of errors / warnings messages and the total
# number of statements analyzed. This is used by the global evaluation report
# (RP0004).
evaluation=10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)

# Template used to display messages. This is a python new-style format string
# used to format the message information. See doc for all details.
#msg-template=

# Set the output format. Available formats are text, parseable, colorized, json
# and msvs (visual studio). You can also give a reporter class, e.g.
# mypackage.mymodule.MyReporterClass.
output-format=text

# Tells whether to display a full report or only the messages.
reports=no

# Activate the evaluation score.
score=yes


[REFACTORING]

# Maximum number of nested blocks for function / method body
max-nested-blocks=5

# Complete name of functions that never returns. When checking for
# inconsistent-return-statements if a never returning function is called then
# it will be considered as an explicit return statement and no message will be
# printed.
never-returning-functions=sys.exit


[BASIC]

# Naming style matching correct argument names.
argument-naming-style=snake_case

# Regular expression matching correct argument names. Overrides argument-
# naming-style.
#argument-rgx=

# Naming style matching correct attribute names.
attr-naming-style=snake_case

# Regular expression matching correct attribute names. Overrides attr-naming-
# style.
#attr-rgx=

# Bad variable names which should always be refused, separated by a comma.
bad-names=foo,
          bar,
          baz,
          toto,
          tutu,
          tata

# Naming style matching correct class attribute names.
class-attribute-naming-style=any

# Regular expression matching correct class attribute names. Overrides class-
# attribute-naming-style.
#class-attribute-rgx=

# Naming style matching correct class names.
class-naming-style=PascalCase

# Regular expression matching correct class names. Overrides class-naming-
# style.
#class-rgx=

# Naming style matching correct constant names.
const-naming-style=UPPER_CASE

# Regular expression matching correct constant names. Overrides const-naming-
# style.
#const-rgx=

# Minimum line length for functions/classes that require docstrings, shorter
# ones are exempt.
docstring-min-length=-1

# Naming style matching correct function names.
function-naming-style=snake_case

# Regular expression matching correct function names. Overrides function-
# naming-style.
#function-rgx=

# Good variable names which should always be accepted, separated by a comma.
good-names=i,
           j,
           k,
           ex,
           Run,
           _

# Include a hint for the correct naming format with invalid-name.
include-naming-hint=no

# Naming style matching correct inline iteration names.
inlinevar-naming-style=any

# Regular expression matching correct inline iteration names. Overrides
# inlinevar-naming-style.
#inlinevar-rgx=

# Naming style matching correct method names.
method-naming-style=snake_case

# Regular expression matching correct method names. Overrides method-naming-
# style.
#method-rgx=

# Naming style matching correct module names.
module-naming-style=snake_case

# Regular expression matching correct module names. Overrides module-naming-
# style.
#module-rgx=

# Colon-delimited sets of names that determine each other's naming style when
# the name regexes allow several styles.
name-group=

# Regular expression which should only match function or class names that do
# not require a docstring.
no-docstring-rgx=^_

# List of decorators that produce properties, such as abc.abstractproperty. Add
# to this list to register other decorators that produce valid properties.
# These decorators are taken in consideration only for invalid-name.
property-classes=abc.abstractproperty

# Naming style matching correct variable names.
variable-naming-style=snake_case

# Regular expression matching correct variable names. Overrides variable-
# naming-style.
#variable-rgx=


[FORMAT]

# Expected format of line ending, e.g. empty (any line ending), LF or CRLF.
expected-line-ending-format=

# Regexp for a line that is allowed to be longer than the limit.
ignore-long-lines=^\s*(# )?<?https?://\S+>?$

# Number of spaces of indent required inside a hanging or continued line.
indent-after-paren=4

# String used as indentation unit. This is usually "    " (4 spaces) or "\t" (1
# tab).
indent-string='    '

# Maximum number of characters on a single line.
max-line-length=100

# Maximum number of lines in a module.
max-module-lines=1000

# List of optional constructs for which whitespace checking is disabled. `dict-
# separator` is used to allow tabulation in dicts, etc.: {1  : 1,\n222: 2}.
# `trailing-comma` allows a space between comma and closing bracket: (a, ).
# `empty-line` allows space-only lines.
no-space-check=trailing-comma,
               dict-separator

# Allow the body of a class to be on the same line as the declaration if body
# contains single statement.
single-line-class-stmt=no

# Allow the body of an if to be on the same line as the test if there is no
# else.
single-line-if-stmt=no


[LOGGING]

# Format style used to check logging format string. `old` means using %
# formatting, while `new` is for `{}` formatting.
logging-format-style=old

# Logging modules to check that the string format arguments are in logging
# function parameter format.
logging-modules=logging


[MISCELLANEOUS]

# List of note tags to take in consideration, separated by a comma.
notes=FIXME,
      XXX,
      TODO


[SIMILARITIES]

# Ignore comments when computing similarities.
ignore-comments=yes

# Ignore docstrings when computing similarities.
ignore-docstrings=yes

# Ignore imports when computing similarities.
ignore-imports=no

# Minimum lines number of a similarity.
min-similarity-lines=4


[SPELLING]

# Limits count of emitted suggestions for spelling mistakes.
max-spelling-suggestions=4

# Spelling dictionary name. Available dictionaries: none. To make it working
# install python-enchant package..
spelling-dict=

# List of comma separated words that should not be checked.
spelling-ignore-words=

# A path to a file that contains private dictionary; one word per line.
spelling-private-dict-file=

# Tells whether to store unknown words to indicated private dictionary in
# --spelling-private-dict-file option instead of raising a message.
spelling-store-unknown-words=no


[STRING]

# This flag controls whether the implicit-str-concat-in-sequence should
# generate a warning on implicit string concatenation in sequences defined over
# several lines.
check-str-concat-over-line-jumps=no


[TYPECHECK]

# List of decorators that produce context managers, such as
# contextlib.contextmanager. Add to this list to register other decorators that
# produce valid context managers.
contextmanager-decorators=contextlib.contextmanager

# List of members which are set dynamically and missed by pylint inference
# system, and so shouldn't trigger E1101 when accessed. Python regular
# expressions are accepted.
generated-members=

# Tells whether missing members accessed in mixin class should be ignored. A
# mixin class is detected if its name ends with "mixin" (case insensitive).
ignore-mixin-members=yes

# Tells whether to warn about missing members when the owner of the attribute
# is inferred to be None.
ignore-none=yes

# This flag controls whether pylint should warn about no-member and similar
# checks whenever an opaque object is returned when inferring. The inference
# can return multiple potential results while evaluating a Python object, but
# some branches might not be evaluated, which results in partial inference. In
# that case, it might be useful to still emit no-member and other checks for
# the rest of the inferred objects.
ignore-on-opaque-inference=yes

# List of class names for which member attributes should not be checked (useful
# for classes with dynamically set attributes). This supports the use of
# qualified names.
ignored-classes=optparse.Values,thread._local,_thread._local

# List of module names for which member attributes should not be checked
# (useful for modules/projects where namespaces are manipulated during runtime
# and thus existing member attributes cannot be deduced by static analysis. It
# supports qualified module names, as well as Unix pattern matching.
ignored-modules=

# Show a hint with possible names when a member name was not found. The aspect
# of finding the hint is based on edit distance.
missing-member-hint=yes

# The minimum edit distance a name should have in order to be considered a
# similar match for a missing member name.
missing-member-hint-distance=1

# The total number of similar names that should be taken in consideration when
# showing a hint for a missing member.
missing-member-max-choices=1


[VARIABLES]

# List of additional names supposed to be defined in builtins. Remember that
# you should avoid defining new builtins when possible.
additional-builtins=

# Tells whether unused global variables should be treated as a violation.
allow-global-unused-variables=yes

# List of strings which can identify a callback function by name. A callback
# name must start or end with one of those strings.
callbacks=cb_,
          _cb

# A regular expression matching the name of dummy variables (i.e. expected to
# not be used).
dummy-variables-rgx=_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_

# Argument names that match this expression will be ignored. Default to name
# with leading underscore.
ignored-argument-names=_.*|^ignored_|^unused_

# Tells whether we should check for unused import in __init__ files.
init-import=no

# List of qualified module names which can have objects that can redefine
# builtins.
redefining-builtins-modules=six.moves,past.builtins,future.builtins,builtins,io


[CLASSES]

# List of method names used to declare (i.e. assign) instance attributes.
defining-attr-methods=__init__,
                      __new__,
                      setUp

# List of member names, which should be excluded from the protected access
# warning.
exclude-protected=_asdict,
                  _fields,
                  _replace,
                  _source,
                  _make

# List of valid names for the first argument in a class method.
valid-classmethod-first-arg=cls

# List of valid names for the first argument in a metaclass class method.
valid-metaclass-classmethod-first-arg=cls


[DESIGN]

# Maximum number of arguments for function / method.
max-args=5

# Maximum number of attributes for a class (see R0902).
max-attributes=7

# Maximum number of boolean expressions in an if statement.
max-bool-expr=5

# Maximum number of branch for function / method body.
max-branches=12

# Maximum number of locals for function / method body.
max-locals=15

# Maximum number of parents for a class (see R0901).
max-parents=7

# Maximum number of public methods for a class (see R0904).
max-public-methods=20

# Maximum number of return / yield for function / method body.
max-returns=6

# Maximum number of statements in function / method body.
max-statements=50

# Minimum number of public methods for a class (see R0903).
min-public-methods=2


[IMPORTS]

# Allow wildcard imports from modules that define __all__.
allow-wildcard-with-all=no

# Analyse import fallback blocks. This can be used to support both Python 2 and
# 3 compatible code, which means that the block might have code that exists
# only in one or another interpreter, leading to false positives when analysed.
analyse-fallback-blocks=no

# Deprecated modules which should not be used, separated by a comma.
deprecated-modules=optparse,tkinter.tix

# Create a graph of external dependencies in the given file (report RP0402 must
# not be disabled).
ext-import-graph=

# Create a graph of every (i.e. internal and external) dependencies in the
# given file (report RP0402 must not be disabled).
import-graph=

# Create a graph of internal dependencies in the given file (report RP0402 must
# not be disabled).
int-import-graph=

# Force import order to recognize a module as part of the standard
# compatibility libraries.
known-standard-library=

# Force import order to recognize a module as part of a third party library.
known-third-party=enchant


[EXCEPTIONS]

# Exceptions that will emit a warning when being caught. Defaults to
# "BaseException, Exception".
overgeneral-exceptions=BaseException,
                       Exception

```

---

## `pyRfactor2SharedMemory\License.txt`

```
MIT License

Copyright (c) 2021 Tony Whitley

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

---

## `pyRfactor2SharedMemory\README.md`

```
![Python application](https://github.com/TonyWhitley/pyRfactor2SharedMemory/workflows/Python%20application/badge.svg)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

# pyRfactor2SharedMemory
Python library for accessing rFactor 2's shared memory

```

---

## `pyRfactor2SharedMemory\__init__.py`

```

```

---

## `pyRfactor2SharedMemory\__pycache__\__init__.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `pyRfactor2SharedMemory\__pycache__\rF2data.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `pyRfactor2SharedMemory\__pycache__\sharedMemoryAPI.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `pyRfactor2SharedMemory\autopep8tree.bat`

```
::@echo off
echo Run autopep8 on two levels of tree

call :autopep
for /d %%d in (*.*) do call :do1level %%d
pause
goto :eof

:do1level
pushd %1
call :autopep
for /d %%d in (*.*) do call :do2ndlevel %%d
popd
goto :eof

:do2ndlevel
cd %1
call :autopep
cd..
goto :eof

:autopep
for %%f in (*.py) do if /i not %%f==rF2data.py autopep8 -i -a -a -a %%f

```

---

## `pyRfactor2SharedMemory\git_sub.cmd`

```
echo git bash commands to load submodules
rem Automated login
git config --global credential.helper wincred

rem rmdir --ignore-fail-on-non-empty pyDirectInputKeySend
git submodule add -f https://github.com/TonyWhitley/hpp2py

```

---

## `pyRfactor2SharedMemory\pyRfactor2SharedMemory.pyproj`

```
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>e3f461f0-82b5-4340-b875-4fbdde85a2f0</ProjectGuid>
    <ProjectHome>.</ProjectHome>
    <StartupFile>sharedMemoryAPI.py</StartupFile>
    <SearchPath>
    </SearchPath>
    <WorkingDirectory>.</WorkingDirectory>
    <OutputPath>.</OutputPath>
    <Name>pyRfactor2SharedMemory</Name>
    <RootNamespace>pyRfactor2SharedMemory</RootNamespace>
    <InterpreterId>MSBuild|env|$(MSBuildProjectFullPath)</InterpreterId>
    <TestFramework>unittest</TestFramework>
    <UnitTestPattern>test*.py</UnitTestPattern>
    <UnitTestRootDirectory>.</UnitTestRootDirectory>
    <SuppressPackageInstallationPrompt>True</SuppressPackageInstallationPrompt>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
    <DebugSymbols>true</DebugSymbols>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <DebugSymbols>true</DebugSymbols>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="rF2data.py" />
    <Compile Include="sharedMemoryAPI.py" />
    <Compile Include="tests\test_sharedMemoryAPI.py" />
    <Compile Include="tests\__init__.py" />
    <Compile Include="__init__.py" />
  </ItemGroup>
  <ItemGroup>
    <Interpreter Include="env\">
      <Id>env</Id>
      <Version>3.7</Version>
      <Description>env (Python 3.7 (64-bit))</Description>
      <InterpreterPath>Scripts\python.exe</InterpreterPath>
      <WindowsInterpreterPath>Scripts\pythonw.exe</WindowsInterpreterPath>
      <PathEnvironmentVariable>PYTHONPATH</PathEnvironmentVariable>
      <Architecture>X64</Architecture>
    </Interpreter>
    <Interpreter Include="pylint\">
      <Id>pylint</Id>
      <Version>3.7</Version>
      <Description>pylint (Python 3.7 (64-bit))</Description>
      <InterpreterPath>Scripts\python.exe</InterpreterPath>
      <WindowsInterpreterPath>Scripts\pythonw.exe</WindowsInterpreterPath>
      <PathEnvironmentVariable>PYTHONPATH</PathEnvironmentVariable>
      <Architecture>X64</Architecture>
    </Interpreter>
  </ItemGroup>
  <ItemGroup>
    <Content Include=".pylintrc" />
    <Content Include="autopep8tree.bat" />
    <Content Include="requirements.txt" />
  </ItemGroup>
  <ItemGroup>
    <Folder Include="tests\" />
  </ItemGroup>
  <Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\Python Tools\Microsoft.PythonTools.targets" />
  <!-- Uncomment the CoreCompile target to enable the Build command in
       Visual Studio and specify your pre- and post-build commands in
       the BeforeBuild and AfterBuild targets below. -->
  <!--<Target Name="CoreCompile" />-->
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
</Project>
```

---

## `pyRfactor2SharedMemory\pyRfactor2SharedMemory.sln`

```
Ôªø
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29215.179
MinimumVisualStudioVersion = 10.0.40219.1
Project("{888888A0-9F3D-457C-B088-3A5042F75D52}") = "pyRfactor2SharedMemory", "pyRfactor2SharedMemory.pyproj", "{E3F461F0-82B5-4340-B875-4FBDDE85A2F0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E3F461F0-82B5-4340-B875-4FBDDE85A2F0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E3F461F0-82B5-4340-B875-4FBDDE85A2F0}.Release|Any CPU.ActiveCfg = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {64C99741-00B3-4BC2-8284-F902A298D281}
	EndGlobalSection
EndGlobal

```

---

## `pyRfactor2SharedMemory\rF2MMap.py`

```
"""
rF2 Memory Map Control

Inherit Python mapping of The Iron Wolf's rF2 Shared Memory Tools

Memory map control (by S.Victor)
Cross-platform Linux support (by Bernat)
"""

from __future__ import annotations

import ctypes
import logging
import mmap
import platform

try:
    from . import rF2data
    from .rF2data import rFactor2Constants
except ImportError:  # standalone, not package
    import rF2data
    from rF2data import rFactor2Constants

PLATFORM = platform.system()
MAX_VEHICLES = rFactor2Constants.MAX_MAPPED_VEHICLES
INVALID_INDEX = -1


def get_root_logger_name():
    """Get root logger name"""
    for logger_name in logging.root.manager.loggerDict:
        return logger_name
    return __name__


logger = logging.getLogger(get_root_logger_name())


def platform_mmap(name: str, size: int, pid: str = "") -> mmap.mmap:
    """Platform memory mapping"""
    if PLATFORM == "Windows":
        return windows_mmap(name, size, pid)
    return linux_mmap(name, size)


def windows_mmap(name: str, size: int, pid: str) -> mmap.mmap:
    """Windows mmap"""
    return mmap.mmap(-1, size, f"{name}{pid}")


def linux_mmap(name: str, size: int) -> mmap.mmap:
    """Linux mmap"""
    file = open("/dev/shm/" + name, "a+b")
    if file.tell() == 0:
        file.write(b"\0" * size)
        file.flush()
    return mmap.mmap(file.fileno(), size)


class MMapControl:
    """Memory map control"""

    __slots__ = (
        "_mmap_name",
        "_mmap_buffer",
        "_struct",
        "_buffer",
        "_version",
        "update",
        "data",
    )

    def __init__(self, mmap_name: str, data_struct: ctypes.Structure) -> None:
        """Initialize memory map setting

        Args:
            mmap_name: mmap filename, ex. $rFactor2SMMP_Scoring$.
            data_struct: ctypes data structure, ex. rF2data.rF2Scoring.
        """
        self._mmap_name = mmap_name
        self._mmap_buffer = None
        self._struct = data_struct
        self._buffer = bytearray()
        self._version = None
        self.update = None
        self.data = None

    def __del__(self):
        logger.info("sharedmemory: GC: MMap %s", self._mmap_name)

    def create(self, access_mode: int = 0, rf2_pid: str = "") -> None:
        """Create mmap instance & initial accessible copy

        Args:
            access_mode: 0 = copy access, 1 = direct access.
            rf2_pid: rF2 Process ID for accessing server data.
        """
        self._mmap_buffer = platform_mmap(
            name=self._mmap_name,
            size=ctypes.sizeof(self._struct),
            pid=rf2_pid
        )

        if access_mode:
            self.data = self._struct.from_buffer(self._mmap_buffer)
            self.update = self.__buffer_share
        else:
            self._buffer[:] = self._mmap_buffer
            self.data = self._struct.from_buffer(self._buffer)
            self._version = rF2data.rF2MappedBufferVersionBlock.from_buffer(self._mmap_buffer)
            self.update = self.__buffer_copy

        mode = "Direct" if access_mode else "Copy"
        logger.info("sharedmemory: ACTIVE: %s (%s Access)", self._mmap_name, mode)

    def close(self) -> None:
        """Close memory mapping

        Create a final accessible mmap data copy before closing mmap instance.
        """
        self.data = self._struct.from_buffer_copy(self._mmap_buffer)
        self._version = None
        try:
            self._mmap_buffer.close()
            logger.info("sharedmemory: CLOSED: %s", self._mmap_name)
        except BufferError:
            logger.error("sharedmemory: buffer error while closing %s", self._mmap_name)
        self.update = None  # unassign update method (for proper garbage collection)

    def __buffer_share(self) -> None:
        """Share buffer access, may result data desync"""

    def __buffer_copy(self) -> None:
        """Copy buffer access, helps avoid data desync"""
        # Copy if data version changed
        if self._version.mVersionUpdateEnd != self.data.mVersionUpdateEnd:
            self._buffer[:] = self._mmap_buffer


def test_api():
    """API test run"""
    # Add logger
    test_handler = logging.StreamHandler()
    logger.setLevel(logging.INFO)
    logger.addHandler(test_handler)

    # Test run
    SEPARATOR = "=" * 50
    print("Test API - Start")
    scoring = MMapControl(rFactor2Constants.MM_SCORING_FILE_NAME, rF2data.rF2Scoring)
    scoring.create(1)
    telemetry = MMapControl(rFactor2Constants.MM_TELEMETRY_FILE_NAME, rF2data.rF2Telemetry)
    telemetry.create(1)
    extended = MMapControl(rFactor2Constants.MM_EXTENDED_FILE_NAME, rF2data.rF2Extended)
    extended.create(1)

    print(SEPARATOR)
    print("Test API - Read")
    version = extended.data.mVersion.decode()
    track = scoring.data.mScoringInfo.mTrackName.decode(encoding="iso-8859-1")
    vehicles = telemetry.data.mNumVehicles
    print(f"plugin ver: {version if version else 'not running'}")
    print(f"track name: {track if version else 'not running'}")
    print(f"total cars: {vehicles if version else 'not running'}")

    print(SEPARATOR)
    print("Test API - Close")
    scoring.close()
    telemetry.close()
    extended.close()


if __name__ == "__main__":
    test_api()

```

---

## `pyRfactor2SharedMemory\rF2Type.py`

```
"""
rF2 API data type hints & annotation

Helper classes with type hints & annotation reference to rF2data.py for IDE & type checker.

Annotate "ctypes type" as "Python type" according to table from:
https://docs.python.org/3/library/ctypes.html#fundamental-data-types

Annotate array object as tuple[type, ...] to specify number of elements contained.
"""

from __future__ import annotations

from abc import ABC, abstractmethod


class _NOINIT(ABC):
    """Disable instantiate"""

    @abstractmethod
    def _(self): ...


class rF2Vec3(_NOINIT):
    x: float
    y: float
    z: float


class rF2Wheel(_NOINIT):
    mSuspensionDeflection: float
    mRideHeight: float
    mSuspForce: float
    mBrakeTemp: float
    mBrakePressure: float
    mRotation: float
    mLateralPatchVel: float
    mLongitudinalPatchVel: float
    mLateralGroundVel: float
    mLongitudinalGroundVel: float
    mCamber: float
    mLateralForce: float
    mLongitudinalForce: float
    mTireLoad: float
    mGripFract: float
    mPressure: float
    mTemperature: tuple[float, float, float]
    mWear: float
    mTerrainName: bytes
    mSurfaceType: int
    mFlat: bool
    mDetached: bool
    mStaticUndeflectedRadius: int
    mVerticalTireDeflection: float
    mWheelYLocation: float
    mToe: float
    mTireCarcassTemperature: float
    mTireInnerLayerTemperature: tuple[float, float, float]
    mExpansion: tuple[int, ...]


class rF2VehicleTelemetry(_NOINIT):
    mID: int
    mDeltaTime: float
    mElapsedTime: float
    mLapNumber: int
    mLapStartET: float
    mVehicleName: bytes
    mTrackName: bytes
    mPos: rF2Vec3
    mLocalVel: rF2Vec3
    mLocalAccel: rF2Vec3
    mOri: tuple[rF2Vec3, rF2Vec3, rF2Vec3]
    mLocalRot: rF2Vec3
    mLocalRotAccel: rF2Vec3
    mGear: int
    mEngineRPM: float
    mEngineWaterTemp: float
    mEngineOilTemp: float
    mClutchRPM: float
    mUnfilteredThrottle: float
    mUnfilteredBrake: float
    mUnfilteredSteering: float
    mUnfilteredClutch: float
    mFilteredThrottle: float
    mFilteredBrake: float
    mFilteredSteering: float
    mFilteredClutch: float
    mSteeringShaftTorque: float
    mFront3rdDeflection: float
    mRear3rdDeflection: float
    mFrontWingHeight: float
    mFrontRideHeight: float
    mRearRideHeight: float
    mDrag: float
    mFrontDownforce: float
    mRearDownforce: float
    mFuel: float
    mEngineMaxRPM: float
    mScheduledStops: int
    mOverheating: bool
    mDetached: bool
    mHeadlights: bool
    mDentSeverity: tuple[int, int, int, int, int, int, int, int]
    mLastImpactET: float
    mLastImpactMagnitude: float
    mLastImpactPos: rF2Vec3
    mEngineTorque: float
    mCurrentSector: int
    mSpeedLimiter: int
    mMaxGears: int
    mFrontTireCompoundIndex: int
    mRearTireCompoundIndex: int
    mFuelCapacity: float
    mFrontFlapActivated: int
    mRearFlapActivated: int
    mRearFlapLegalStatus: int
    mIgnitionStarter: int
    mFrontTireCompoundName: bytes
    mRearTireCompoundName: bytes
    mSpeedLimiterAvailable: int
    mAntiStallActivated: int
    mUnused: tuple[int, int]
    mVisualSteeringWheelRange: float
    mRearBrakeBias: float
    mTurboBoostPressure: float
    mPhysicsToGraphicsOffset: tuple[float, float, float]
    mPhysicalSteeringWheelRange: float
    mDeltaBest: float
    mBatteryChargeFraction: float
    mElectricBoostMotorTorque: float
    mElectricBoostMotorRPM: float
    mElectricBoostMotorTemperature: float
    mElectricBoostWaterTemperature: float
    mElectricBoostMotorState: int
    mExpansion: tuple[int, ...]
    mWheels: tuple[rF2Wheel, rF2Wheel, rF2Wheel, rF2Wheel]


class rF2ScoringInfo(_NOINIT):
    mTrackName: bytes
    mSession: int
    mCurrentET: float
    mEndET: float
    mMaxLaps: int
    mLapDist: float
    pointer1: tuple[int, ...]
    mNumVehicles: int
    mGamePhase: int
    mYellowFlagState: int
    mSectorFlag: tuple[int, int, int]
    mStartLight: int
    mNumRedLights: int
    mInRealtime: bool
    mPlayerName: bytes
    mPlrFileName: bytes
    mDarkCloud: float
    mRaining: float
    mAmbientTemp: float
    mTrackTemp: float
    mWind: rF2Vec3
    mMinPathWetness: float
    mMaxPathWetness: float
    mGameMode: int
    mIsPasswordProtected: bool
    mServerPort: int
    mServerPublicIP: int
    mMaxPlayers: int
    mServerName: bytes
    mStartET: float
    mAvgPathWetness: float
    mExpansion: tuple[int, ...]
    pointer2: tuple[int, ...]


class rF2VehicleScoring(_NOINIT):
    mID: int
    mDriverName: bytes
    mVehicleName: bytes
    mTotalLaps: int
    mSector: int
    mFinishStatus: int
    mLapDist: float
    mPathLateral: float
    mTrackEdge: float
    mBestSector1: float
    mBestSector2: float
    mBestLapTime: float
    mLastSector1: float
    mLastSector2: float
    mLastLapTime: float
    mCurSector1: float
    mCurSector2: float
    mNumPitstops: int
    mNumPenalties: int
    mIsPlayer: bool
    mControl: int
    mInPits: bool
    mPlace: int
    mVehicleClass: bytes
    mTimeBehindNext: float
    mLapsBehindNext: int
    mTimeBehindLeader: float
    mLapsBehindLeader: int
    mLapStartET: float
    mPos: rF2Vec3
    mLocalVel: rF2Vec3
    mLocalAccel: rF2Vec3
    mOri: tuple[rF2Vec3, rF2Vec3, rF2Vec3]
    mLocalRot: rF2Vec3
    mLocalRotAccel: rF2Vec3
    mHeadlights: int
    mPitState: int
    mServerScored: int
    mIndividualPhase: int
    mQualification: int
    mTimeIntoLap: float
    mEstimatedLapTime: float
    mPitGroup: bytes
    mFlag: int
    mUnderYellow: bool
    mCountLapFlag: int
    mInGarageStall: bool
    mUpgradePack: tuple[int, ...]
    mPitLapDist: float
    mBestLapSector1: float
    mBestLapSector2: float
    mExpansion: tuple[int, ...]


class rF2PhysicsOptions(_NOINIT):
    mTractionControl: int
    mAntiLockBrakes: int
    mStabilityControl: int
    mAutoShift: int
    mAutoClutch: int
    mInvulnerable: int
    mOppositeLock: int
    mSteeringHelp: int
    mBrakingHelp: int
    mSpinRecovery: int
    mAutoPit: int
    mAutoLift: int
    mAutoBlip: int
    mFuelMult: int
    mTireMult: int
    mMechFail: int
    mAllowPitcrewPush: int
    mRepeatShifts: int
    mHoldClutch: int
    mAutoReverse: int
    mAlternateNeutral: int
    mAIControl: int
    mUnused1: int
    mUnused2: int
    mManualShiftOverrideTime: float
    mAutoShiftOverrideTime: float
    mSpeedSensitiveSteering: float
    mSteerRatioSpeed: float


class rF2TrackRulesAction(_NOINIT):
    mCommand: int
    mID: int
    mET: float


class rF2TrackRulesParticipant(_NOINIT):
    mID: int
    mFrozenOrder: int
    mPlace: int
    mYellowSeverity: float
    mCurrentRelativeDistance: float
    mRelativeLaps: int
    mColumnAssignment: int
    mPositionAssignment: int
    mPitsOpen: int
    mUpToSpeed: bool
    mUnused: tuple[bool, bool]
    mGoalRelativeDistance: float
    mMessage: bytes
    mExpansion: tuple[int, ...]


class rF2TrackRules(_NOINIT):
    mCurrentET: float
    mStage: int
    mPoleColumn: int
    mNumActions: int
    pointer1: tuple[int, ...]
    mNumParticipants: int
    mYellowFlagDetected: bool
    mYellowFlagLapsWasOverridden: int
    mSafetyCarExists: bool
    mSafetyCarActive: bool
    mSafetyCarLaps: int
    mSafetyCarThreshold: float
    mSafetyCarLapDist: float
    mSafetyCarLapDistAtStart: float
    mPitLaneStartDist: float
    mTeleportLapDist: float
    mInputExpansion: tuple[int, ...]
    mYellowFlagState: int
    mYellowFlagLaps: int
    mSafetyCarInstruction: int
    mSafetyCarSpeed: float
    mSafetyCarMinimumSpacing: float
    mSafetyCarMaximumSpacing: float
    mMinimumColumnSpacing: float
    mMaximumColumnSpacing: float
    mMinimumSpeed: float
    mMaximumSpeed: float
    mMessage: bytes
    pointer2: tuple[int, ...]
    mInputOutputExpansion: tuple[int, ...]


class rF2PitMenu(_NOINIT):
    mCategoryIndex: int
    mCategoryName: bytes
    mChoiceIndex: int
    mChoiceString: bytes
    mNumChoices: int
    mExpansion: tuple[int, ...]


class rF2WeatherControlInfo(_NOINIT):
    mET: float
    mRaining: tuple[float, float, float, float, float, float, float, float, float]
    mCloudiness: float
    mAmbientTempK: float
    mWindMaxSpeed: float
    mApplyCloudinessInstantly: bool
    mUnused1: bool
    mUnused2: bool
    mUnused3: bool
    mExpansion: tuple[int, ...]


class rF2MappedBufferVersionBlock(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int


class rF2MappedBufferVersionBlockWithSize(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mBytesUpdatedHint: int


class rF2Telemetry(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mBytesUpdatedHint: int
    mNumVehicles: int
    mVehicles: tuple[rF2VehicleTelemetry, ...]


class rF2Scoring(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mBytesUpdatedHint: int
    mScoringInfo: rF2ScoringInfo
    mVehicles: tuple[rF2VehicleScoring, ...]


class rF2Rules(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mBytesUpdatedHint: int
    mTrackRules: rF2TrackRules
    mActions: tuple[rF2TrackRulesAction, ...]
    mParticipants: tuple[rF2TrackRulesParticipant, ...]


class rF2ForceFeedback(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mForceValue: float


class rF2GraphicsInfo(_NOINIT):
    mCamPos: rF2Vec3
    mCamOri: tuple[rF2Vec3, rF2Vec3, rF2Vec3]
    mHWND: tuple[int, ...]
    mAmbientRed: float
    mAmbientGreen: float
    mAmbientBlue: float
    mID: int
    mCameraType: int
    mExpansion: tuple[int, ...]


class rF2Graphics(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mGraphicsInfo: rF2GraphicsInfo


class rF2PitInfo(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mPitMenu: rF2PitMenu


class rF2Weather(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mTrackNodeSize: float
    mWeatherInfo: rF2WeatherControlInfo


class rF2TrackedDamage(_NOINIT):
    mMaxImpactMagnitude: float
    mAccumulatedImpactMagnitude: float


class rF2VehScoringCapture(_NOINIT):
    mID: int
    mPlace: int
    mIsPlayer: bool
    mFinishStatus: int


class rF2SessionTransitionCapture(_NOINIT):
    mGamePhase: int
    mSession: int
    mNumScoringVehicles: int
    mScoringVehicles: tuple[rF2VehScoringCapture, ...]


class rF2Extended(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mVersion: bytes
    is64bit: bool
    mPhysics: rF2PhysicsOptions
    mTrackedDamages: tuple[rF2TrackedDamage, ...]
    mInRealtimeFC: bool
    mMultimediaThreadStarted: bool
    mSimulationThreadStarted: bool
    mSessionStarted: bool
    mTicksSessionStarted: int
    mTicksSessionEnded: int
    mSessionTransitionCapture: rF2SessionTransitionCapture
    mDisplayedMessageUpdateCapture: bytes
    mDirectMemoryAccessEnabled: bool
    mTicksStatusMessageUpdated: int
    mStatusMessage: bytes
    mTicksLastHistoryMessageUpdated: int
    mLastHistoryMessage: bytes
    mCurrentPitSpeedLimit: float
    mSCRPluginEnabled: bool
    mSCRPluginDoubleFileType: int
    mTicksLSIPhaseMessageUpdated: int
    mLSIPhaseMessage: bytes
    mTicksLSIPitStateMessageUpdated: int
    mLSIPitStateMessage: bytes
    mTicksLSIOrderInstructionMessageUpdated: int
    mLSIOrderInstructionMessage: bytes
    mTicksLSIRulesInstructionMessageUpdated: int
    mLSIRulesInstructionMessage: bytes
    mUnsubscribedBuffersMask: int
    mHWControlInputEnabled: bool
    mWeatherControlInputEnabled: bool
    mRulesControlInputEnabled: bool


class rF2HWControl(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mLayoutVersion: int
    mControlName: bytes
    mfRetVal: float


class rF2WeatherControl(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mLayoutVersion: int
    mWeatherInfo: rF2WeatherControlInfo


class rF2RulesControl(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mLayoutVersion: int
    mTrackRules: rF2TrackRules
    mActions: tuple[rF2TrackRulesAction, ...]
    mParticipants: tuple[rF2TrackRulesParticipant, ...]


class rF2PluginControl(_NOINIT):
    mVersionUpdateBegin: int
    mVersionUpdateEnd: int
    mLayoutVersion: int
    mRequestEnableBuffersMask: int
    mRequestHWControlInput: int
    mRequestWeatherControlInput: int
    mRequestRulesControlInput: int

```

---

## `pyRfactor2SharedMemory\rF2data.py`

```
"""
Python mapping of The Iron Wolf's rF2 Shared Memory Tools
Auto-generated from rF2data.cs
"""
# pylint: disable=C,R,W

import ctypes
import mmap
from enum import Enum, Flag


class rFactor2Constants:
    MM_TELEMETRY_FILE_NAME: str = "$rFactor2SMMP_Telemetry$"
    MM_SCORING_FILE_NAME: str = "$rFactor2SMMP_Scoring$"
    MM_RULES_FILE_NAME: str = "$rFactor2SMMP_Rules$"
    MM_FORCE_FEEDBACK_FILE_NAME: str = "$rFactor2SMMP_ForceFeedback$"
    MM_GRAPHICS_FILE_NAME: str = "$rFactor2SMMP_Graphics$"
    MM_PITINFO_FILE_NAME: str = "$rFactor2SMMP_PitInfo$"
    MM_WEATHER_FILE_NAME: str = "$rFactor2SMMP_Weather$"
    MM_EXTENDED_FILE_NAME: str = "$rFactor2SMMP_Extended$"

    MM_HWCONTROL_FILE_NAME: str = "$rFactor2SMMP_HWControl$"
    MM_HWCONTROL_LAYOUT_VERSION: int = 1

    MM_WEATHER_CONTROL_FILE_NAME: str = "$rFactor2SMMP_WeatherControl$"
    MM_WEATHER_CONTROL_LAYOUT_VERSION: int = 1

    MM_RULES_CONTROL_FILE_NAME: str = "$rFactor2SMMP_RulesControl$"
    MM_RULES_CONTROL_LAYOUT_VERSION: int = 1

    MM_PLUGIN_CONTROL_FILE_NAME: str = "$rFactor2SMMP_PluginControl$"
    MM_PLUGIN_CONTROL_LAYOUT_VERSION: int = 1

    MAX_MAPPED_VEHICLES: int = 128
    MAX_MAPPED_IDS: int = 512
    MAX_STATUS_MSG_LEN: int = 128
    MAX_RULES_INSTRUCTION_MSG_LEN: int = 96
    MAX_HWCONTROL_NAME_LEN: int = 96

    RFACTOR2_PROCESS_NAME: str = "rFactor2"
    RFACTOR2_DEVMODE_PROCESS_NAME: str = "rFactor2 Mod Mode"
    RFACTOR2_DEDICATED_PROCESS_NAME: str = "rFactor2 Dedicated"


"""
# untranslated /*
rF2 internal state mapping structures.  Allows access to native C++ structs from C
# untranslated Must be kept in sync with Include\rF2State.h.
# untranslated See: MainForm.MainUpdate for sample on how to marshall from native in memory struct.
# untranslated Author: The Iron Wolf (vleonavicius@hotmail.com)
# untranslated Website: thecrewchief.org
# untranslated */
# untranslated using Newtonsoft.Json;
# untranslated using System;
# untranslated using System.Runtime.InteropServices;
# untranslated using System.Xml.Serialization;
# untranslated namespace rF2SharedMemory
class rFactor2Constants
    const byte RowX = 0;
    const byte RowY = 1;
    const byte RowZ = 2;
"""


class SubscribedBuffer(Flag):
    """Subscribed buffer flag"""

    Telemetry = 1
    Scoring = 2
    Rules = 4
    MultiRules = 8
    ForceFeedback = 16
    Graphics = 32
    PitInfo = 64
    Weather = 128
    All = 255


class rF2GamePhase(Enum):
    """
    Game phase states

    0=Before session has begun,
    1=Reconnaissance laps (race only),
    2=Grid walk-through (race only),
    3=Formation lap (race only),
    4=Starting-light countdown has begun (race only),
    5=Green flag,
    6=Full course yellow / safety car,
    7=Session stopped,
    8=Session over,
    9=Paused (tag.2015.09.14 - this is new, and indicates that this is a heartbeat call to the plugin)
    """

    Garage = 0
    WarmUp = 1
    GridWalk = 2
    Formation = 3
    Countdown = 4
    GreenFlag = 5
    FullCourseYellow = 6
    SessionStopped = 7
    SessionOver = 8
    PausedOrHeartbeat = 9


class rF2YellowFlagState(Enum):
    """
    Yellow flag states (applies to full-course only)

    -1=Invalid,
    0=None,
    1=Pending,
    2=Pits closed,
    3=Pit lead lap,
    4=Pits open,
    5=Last lap,
    6=Resume,
    7=Race halt (not currently used),
    """

    Invalid = -1
    NoFlag = 0
    Pending = 1
    PitClosed = 2
    PitLeadLap = 3
    PitOpen = 4
    LastLap = 5
    Resume = 6
    RaceHalt = 7


class rF2SurfaceType(Enum):
    """
    Surface type

    0=dry,
    1=wet,
    2=grass,
    3=dirt,
    4=gravel,
    5=rumblestrip,
    6=special
    """

    Dry = 0
    Wet = 1
    Grass = 2
    Dirt = 3
    Gravel = 4
    Kerb = 5
    Special = 6


class rF2Sector(Enum):
    """
    Sector index

    0=sector3,
    1=sector1,
    2=sector2 (don't ask why)
    """

    Sector3 = 0
    Sector1 = 1
    Sector2 = 2


class rF2FinishStatus(Enum):
    """Finish status

    0=none,
    1=finished,
    2=dnf,
    3=dq
    """

    _None = 0
    Finished = 1
    Dnf = 2
    Dq = 3


class rF2Control(Enum):
    """
    Who's in control

    -1=nobody (shouldn't get this),
    0=local player,
    1=local AI,
    2=remote,
    3=replay (shouldn't get this)
    """

    Nobody = -1
    Player = 0
    AI = 1
    Remote = 2
    Replay = 3


class rF2WheelIndex(Enum):
    """Wheel index

    front left=0,
    front right=1,
    rear left=2,
    rear right=3
    """

    FrontLeft = 0
    FrontRight = 1
    RearLeft = 2
    RearRight = 3


class rF2PitState(Enum):
    """Pit state

    0=none,
    1=request,
    2=entering,
    3=stopped,
    4=exiting
    """

    _None = 0
    Request = 1
    Entering = 2
    Stopped = 3
    Exiting = 4


class rF2PrimaryFlag(Enum):
    """
    Primary flag being shown to vehicle

    0=green,
    6=blue
    """

    Green = 0
    Blue = 6


class rF2CountLapFlag(Enum):
    """Count lap flag

    0=do not count lap or time,
    1=count lap but not time,
    2=count lap and time
    """

    DoNotCountLap = 0
    CountLapButNotTime = 1
    CountLapAndTime = 2


class rF2RearFlapLegalStatus(Enum):
    """
    Rear flap (DRS) status

    0=disallowed,
    1=criteria detected but not allowed quite yet,
    2=allowed
    """

    Disallowed = 0
    DetectedButNotAllowedYet = 1
    Alllowed = 2


class rF2IgnitionStarterStatus(Enum):
    """
    Ignition starter status

    0=off,
    1=ignition,
    2=ignition+starter
    """

    Off = 0
    Ignition = 1
    IgnitionAndStarter = 2


class rF2SafetyCarInstruction(Enum):
    """Safety car instruction

    0=no change,
    1=go active,
    2=head for pits
    """

    NoChange = 0
    GoActive = 1
    HeadForPits = 2


class rF2TrackRulesCommand(Enum):
    AddFromTrack = 0
    AddFromPit = 1        # exited pit during full-course yellow
    AddFromUndq = 2       # during a full-course yellow, the admin reversed a disqualification
    RemoveToPit = 3       # entered pit during full-course yellow
    RemoveToDnf = 4       # vehicle DNF'd during full-course yellow
    RemoveToDq = 5        # vehicle DQ'd during full-course yellow
    RemoveToUnloaded = 6  # vehicle unloaded (possibly kicked out or banned) during full-course yellow
    MoveToBack = 7        # misbehavior during full-course yellow, resulting in the penalty of being moved to the back of their current line
    LongestTime = 8       # misbehavior during full-course yellow, resulting in the penalty of being moved to the back of the longest line
    Maximum = 9           # should be last


class rF2TrackRulesColumn(Enum):
    LeftLane = 0
    MidLefLane = 1      # mid-left
    MiddleLane = 2      # middle
    MidrRghtLane = 3    # mid-right
    RightLane = 4       # right (outside)
    MaxLanes = 5        # should be after the valid static lane choices
    Invalid = MaxLanes
    FreeChoice = 6      # free choice (dynamically chosen by driver)
    Pending = 7         # depends on another participant's free choice (dynamically set after another driver chooses)
    Maximum = 8         # should be last


class rF2TrackRulesStage(Enum):
    FormationInit = 0
    FormationUpdate = 1  # update of the formation lap
    Normal = 2           # normal (non-yellow) update
    CautionInit = 3      # initialization of a full-course yellow
    CautionUpdate = 4    # update of a full-course yellow
    Maximum = 5          # should be last


# untranslated namespace rFactor2Data
# untranslated [StructLayout(LayoutKind.Sequential, Pack = 4)]
class rF2Vec3(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("x", ctypes.c_double),
        ("y", ctypes.c_double),
        ("z", ctypes.c_double),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Wheel(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mSuspensionDeflection", ctypes.c_double),         # meters
        ("mRideHeight", ctypes.c_double),                   # meters
        ("mSuspForce", ctypes.c_double),                    # pushrod load in Newtons
        ("mBrakeTemp", ctypes.c_double),                    # Celsius
        ("mBrakePressure", ctypes.c_double),                # currently 0.0-1.0, depending on driver input and brake balance; will convert to true brake pressure (kPa) in future
        ("mRotation", ctypes.c_double),                     # radians/sec
        ("mLateralPatchVel", ctypes.c_double),              # lateral velocity at contact patch
        ("mLongitudinalPatchVel", ctypes.c_double),         # longitudinal velocity at contact patch
        ("mLateralGroundVel", ctypes.c_double),             # lateral velocity at contact patch
        ("mLongitudinalGroundVel", ctypes.c_double),        # longitudinal velocity at contact patch
        ("mCamber", ctypes.c_double),                       # radians (positive is left for left-side wheels, right for right-side wheels)
        ("mLateralForce", ctypes.c_double),                 # Newtons
        ("mLongitudinalForce", ctypes.c_double),            # Newtons
        ("mTireLoad", ctypes.c_double),                     # Newtons
        ("mGripFract", ctypes.c_double),                    # an approximation of what fraction of the contact patch is sliding
        ("mPressure", ctypes.c_double),                     # kPa (tire pressure)
        ("mTemperature", ctypes.c_double*3),                # Kelvin (subtract 273.15 to get Celsius), left/center/right (not to be confused with inside/center/outside!)
        ("mWear", ctypes.c_double),                         # wear (0.0-1.0, fraction of maximum) ... this is not necessarily proportional with grip loss
        ("mTerrainName", ctypes.c_char*16),                 # the material prefixes from the TDF file
        ("mSurfaceType", ctypes.c_ubyte),                   # 0=dry, 1=wet, 2=grass, 3=dirt, 4=gravel, 5=rumblestrip, 6 = special
        ("mFlat", ctypes.c_bool),                           # whether tire is flat
        ("mDetached", ctypes.c_bool),                       # whether wheel is detached
        ("mStaticUndeflectedRadius", ctypes.c_ubyte),       # tire radius in centimeters
        ("mVerticalTireDeflection", ctypes.c_double),       # how much is tire deflected from its (speed-sensitive) radius
        ("mWheelYLocation", ctypes.c_double),               # wheel's y location relative to vehicle y location
        ("mToe", ctypes.c_double),                          # current toe angle w.r.t. the vehicle
        ("mTireCarcassTemperature", ctypes.c_double),       # rough average of temperature samples from carcass (Kelvin)
        ("mTireInnerLayerTemperature", ctypes.c_double*3),  # rough average of temperature samples from innermost layer of rubber (before carcass) (Kelvin)
        ("mExpansion", ctypes.c_ubyte*24),                  # for future use
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2VehicleTelemetry(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mID", ctypes.c_int),                                # slot ID (note that it can be re-used in multiplayer after someone leaves)
        ("mDeltaTime", ctypes.c_double),                      # time since last update (seconds)
        ("mElapsedTime", ctypes.c_double),                    # game session time
        ("mLapNumber", ctypes.c_int),                         # current lap number
        ("mLapStartET", ctypes.c_double),                     # time this lap was started
        ("mVehicleName", ctypes.c_char*64),                   # current vehicle name
        ("mTrackName", ctypes.c_char*64),                     # current track name
        ("mPos", rF2Vec3),                                    # world position in meters
        ("mLocalVel", rF2Vec3),                               # velocity (meters/sec) in local vehicle coordinates
        ("mLocalAccel", rF2Vec3),                             # acceleration (meters/sec^2) in local vehicle coordinates
        ("mOri", rF2Vec3*3),                                  # rows of orientation matrix (use TelemQuat conversions if desired), also converts local
        ("mLocalRot", rF2Vec3),                               # rotation (radians/sec) in local vehicle coordinates
        ("mLocalRotAccel", rF2Vec3),                          # rotational acceleration (radians/sec^2) in local vehicle coordinates
        ("mGear", ctypes.c_int),                              # -1=reverse, 0=neutral, 1+ = forward gears
        ("mEngineRPM", ctypes.c_double),                      # engine RPM
        ("mEngineWaterTemp", ctypes.c_double),                # Celsius
        ("mEngineOilTemp", ctypes.c_double),                  # Celsius
        ("mClutchRPM", ctypes.c_double),                      # clutch RPM
        ("mUnfilteredThrottle", ctypes.c_double),             # ranges  0.0-1.0
        ("mUnfilteredBrake", ctypes.c_double),                # ranges  0.0-1.0
        ("mUnfilteredSteering", ctypes.c_double),             # ranges -1.0-1.0 (left to right)
        ("mUnfilteredClutch", ctypes.c_double),               # ranges  0.0-1.0
        ("mFilteredThrottle", ctypes.c_double),               # ranges  0.0-1.0
        ("mFilteredBrake", ctypes.c_double),                  # ranges  0.0-1.0
        ("mFilteredSteering", ctypes.c_double),               # ranges -1.0-1.0 (left to right)
        ("mFilteredClutch", ctypes.c_double),                 # ranges  0.0-1.0
        ("mSteeringShaftTorque", ctypes.c_double),            # torque around steering shaft (used to be mSteeringArmForce, but that is not necessarily accurate for feedback purposes)
        ("mFront3rdDeflection", ctypes.c_double),             # deflection at front 3rd spring
        ("mRear3rdDeflection", ctypes.c_double),              # deflection at rear 3rd spring
        ("mFrontWingHeight", ctypes.c_double),                # front wing height
        ("mFrontRideHeight", ctypes.c_double),                # front ride height
        ("mRearRideHeight", ctypes.c_double),                 # rear ride height
        ("mDrag", ctypes.c_double),                           # drag
        ("mFrontDownforce", ctypes.c_double),                 # front downforce
        ("mRearDownforce", ctypes.c_double),                  # rear downforce
        ("mFuel", ctypes.c_double),                           # amount of fuel (liters)
        ("mEngineMaxRPM", ctypes.c_double),                   # rev limit
        ("mScheduledStops", ctypes.c_ubyte),                  # number of scheduled pitstops
        ("mOverheating", ctypes.c_bool),                      # whether overheating icon is shown
        ("mDetached", ctypes.c_bool),                         # whether any parts (besides wheels) have been detached
        ("mHeadlights", ctypes.c_bool),                       # whether headlights are on
        ("mDentSeverity", ctypes.c_ubyte*8),                  # dent severity at 8 locations around the car (0=none, 1=some, 2=more)
        ("mLastImpactET", ctypes.c_double),                   # time of last impact
        ("mLastImpactMagnitude", ctypes.c_double),            # magnitude of last impact
        ("mLastImpactPos", rF2Vec3),                          # location of last impact
        ("mEngineTorque", ctypes.c_double),                   # current engine torque (including additive torque) (used to be mEngineTq, but there's little reason to abbreviate it)
        ("mCurrentSector", ctypes.c_int),                     # the current sector (zero-based) with the pitlane stored in the sign bit (example: entering pits from third sector gives 0x80000002)
        ("mSpeedLimiter", ctypes.c_ubyte),                    # whether speed limiter is on
        ("mMaxGears", ctypes.c_ubyte),                        # maximum forward gears
        ("mFrontTireCompoundIndex", ctypes.c_ubyte),          # index within brand
        ("mRearTireCompoundIndex", ctypes.c_ubyte),           # index within brand
        ("mFuelCapacity", ctypes.c_double),                   # capacity in liters
        ("mFrontFlapActivated", ctypes.c_ubyte),              # whether front flap is activated
        ("mRearFlapActivated", ctypes.c_ubyte),               # whether rear flap is activated
        ("mRearFlapLegalStatus", ctypes.c_ubyte),             # 0=disallowed, 1=criteria detected but not allowed quite yet, 2 = allowed
        ("mIgnitionStarter", ctypes.c_ubyte),                 # 0=off 1=ignition 2 = ignition+starter
        ("mFrontTireCompoundName", ctypes.c_char*18),         # name of front tire compound
        ("mRearTireCompoundName", ctypes.c_char*18),          # name of rear tire compound
        ("mSpeedLimiterAvailable", ctypes.c_ubyte),           # whether speed limiter is available
        ("mAntiStallActivated", ctypes.c_ubyte),              # whether (hard) anti-stall is activated
        ("mUnused", ctypes.c_ubyte*2),                        #
        ("mVisualSteeringWheelRange", ctypes.c_float),        # the *visual* steering wheel range
        ("mRearBrakeBias", ctypes.c_double),                  # fraction of brakes on rear
        ("mTurboBoostPressure", ctypes.c_double),             # current turbo boost pressure if available
        ("mPhysicsToGraphicsOffset", ctypes.c_float*3),       # offset from static CG to graphical center
        ("mPhysicalSteeringWheelRange", ctypes.c_float),      # the *physical* steering wheel range
        ("mDeltaBest", ctypes.c_double),                      # (omitted in error by S397)
        ("mBatteryChargeFraction", ctypes.c_double),          # Battery charge as fraction [0.0-1.0]
        ("mElectricBoostMotorTorque", ctypes.c_double),       # current torque of boost motor (can be negative when in regenerating mode)
        ("mElectricBoostMotorRPM", ctypes.c_double),          # current rpm of boost motor
        ("mElectricBoostMotorTemperature", ctypes.c_double),  # current temperature of boost motor
        ("mElectricBoostWaterTemperature", ctypes.c_double),  # current water temperature of boost motor cooler if present (0 otherwise)
        ("mElectricBoostMotorState", ctypes.c_ubyte),         # 0=unavailable 1=inactive, 2=propulsion, 3=regeneration
        ("mExpansion", ctypes.c_ubyte*103),                   # for future use (note that the slot ID has been moved to mID above)
        ("mWheels", rF2Wheel*4),                              # wheel info (front left, front right, rear left, rear right)
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2ScoringInfo(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mTrackName", ctypes.c_char*64),         # current track name
        ("mSession", ctypes.c_int),               # current session (0=testday 1-4=practice 5-8=qual 9=warmup 10-13 = race)
        ("mCurrentET", ctypes.c_double),          # current time
        ("mEndET", ctypes.c_double),              # ending time
        ("mMaxLaps", ctypes.c_int),               # maximum laps
        ("mLapDist", ctypes.c_double),            # distance around track
        ("pointer1", ctypes.c_ubyte*8),
        ("mNumVehicles", ctypes.c_int),           # current number of vehicles
        ("mGamePhase", ctypes.c_ubyte),
        ("mYellowFlagState", ctypes.c_char),
        ("mSectorFlag", ctypes.c_ubyte*3),        # whether there are any local yellows at the moment in each sector (not sure if sector 0 is first or last, so test)
        ("mStartLight", ctypes.c_ubyte),          # start light frame (number depends on track)
        ("mNumRedLights", ctypes.c_ubyte),        # number of red lights in start sequence
        ("mInRealtime", ctypes.c_bool),           # in realtime as opposed to at the monitor
        ("mPlayerName", ctypes.c_char*32),        # player name (including possible multiplayer override)
        ("mPlrFileName", ctypes.c_char*64),       # may be encoded to be a legal filename
        ("mDarkCloud", ctypes.c_double),          # cloud darkness? 0.0-1.0
        ("mRaining", ctypes.c_double),            # raining severity 0.0-1.0
        ("mAmbientTemp", ctypes.c_double),        # temperature (Celsius)
        ("mTrackTemp", ctypes.c_double),          # temperature (Celsius)
        ("mWind", rF2Vec3),                       # wind speed
        ("mMinPathWetness", ctypes.c_double),     # minimum wetness on main path 0.0-1.0
        ("mMaxPathWetness", ctypes.c_double),     # maximum wetness on main path 0.0-1.0
        ("mGameMode", ctypes.c_ubyte),            # 1 = server, 2 = client, 3 = server and client
        ("mIsPasswordProtected", ctypes.c_bool),  # is the server password protected
        ("mServerPort", ctypes.c_ushort),         # the port of the server (if on a server)
        ("mServerPublicIP", ctypes.c_uint),       # the public IP address of the server (if on a server)
        ("mMaxPlayers", ctypes.c_int),            # maximum number of vehicles that can be in the session
        ("mServerName", ctypes.c_char*32),        # name of the server
        ("mStartET", ctypes.c_float),             # start time (seconds since midnight) of the event
        ("mAvgPathWetness", ctypes.c_double),     # average wetness on main path 0.0-1.0
        ("mExpansion", ctypes.c_ubyte*200),
        ("pointer2", ctypes.c_ubyte*8),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2VehicleScoring(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mID", ctypes.c_int),                   # slot ID (note that it can be re-used in multiplayer after someone leaves)
        ("mDriverName", ctypes.c_char*32),       # driver name
        ("mVehicleName", ctypes.c_char*64),      # vehicle name
        ("mTotalLaps", ctypes.c_short),          # laps completed
        ("mSector", ctypes.c_byte),              # 0=sector3, 1=sector1, 2 = sector2 (don't ask why)
        ("mFinishStatus", ctypes.c_byte),        # 0=none, 1=finished, 2=dnf, 3 = dq
        ("mLapDist", ctypes.c_double),           # current distance around track
        ("mPathLateral", ctypes.c_double),       # lateral position with respect to *very approximate* "center" path
        ("mTrackEdge", ctypes.c_double),         # track edge (w.r.t. "center" path) on same side of track as vehicle
        ("mBestSector1", ctypes.c_double),       # best sector 1
        ("mBestSector2", ctypes.c_double),       # best sector 2 (plus sector 1)
        ("mBestLapTime", ctypes.c_double),       # best lap time
        ("mLastSector1", ctypes.c_double),       # last sector 1
        ("mLastSector2", ctypes.c_double),       # last sector 2 (plus sector 1)
        ("mLastLapTime", ctypes.c_double),       # last lap time
        ("mCurSector1", ctypes.c_double),        # current sector 1 if valid
        ("mCurSector2", ctypes.c_double),        # current sector 2 (plus sector 1) if valid
        ("mNumPitstops", ctypes.c_short),        # number of pitstops made
        ("mNumPenalties", ctypes.c_short),       # number of outstanding penalties
        ("mIsPlayer", ctypes.c_bool),            # is this the player's vehicle
        ("mControl", ctypes.c_byte),             # who's in control: -1=nobody (shouldn't get this), 0=local player, 1=local AI, 2=remote, 3 = replay (shouldn't get this)
        ("mInPits", ctypes.c_bool),              # between pit entrance and pit exit (not always accurate for remote vehicles)
        ("mPlace", ctypes.c_ubyte),              # 1-based position
        ("mVehicleClass", ctypes.c_char*32),     # vehicle class
        ("mTimeBehindNext", ctypes.c_double),    # time behind vehicle in next higher place
        ("mLapsBehindNext", ctypes.c_int),       # laps behind vehicle in next higher place
        ("mTimeBehindLeader", ctypes.c_double),  # time behind leader
        ("mLapsBehindLeader", ctypes.c_int),     # laps behind leader
        ("mLapStartET", ctypes.c_double),        # time this lap was started
        ("mPos", rF2Vec3),                       # world position in meters
        ("mLocalVel", rF2Vec3),                  # velocity (meters/sec) in local vehicle coordinates
        ("mLocalAccel", rF2Vec3),                # acceleration (meters/sec^2) in local vehicle coordinates
        ("mOri", rF2Vec3*3),                     # rows of orientation matrix (use TelemQuat conversions if desired), also converts local
        ("mLocalRot", rF2Vec3),                  # rotation (radians/sec) in local vehicle coordinates
        ("mLocalRotAccel", rF2Vec3),             # rotational acceleration (radians/sec^2) in local vehicle coordinates
        ("mHeadlights", ctypes.c_ubyte),         # status of headlights
        ("mPitState", ctypes.c_ubyte),           # 0=none, 1=request, 2=entering, 3=stopped, 4 = exiting
        ("mServerScored", ctypes.c_ubyte),       # whether this vehicle is being scored by server (could be off in qualifying or racing heats)
        ("mIndividualPhase", ctypes.c_ubyte),    # game phases (described below) plus 9=after formation, 10=under yellow, 11 = under blue (not used)
        ("mQualification", ctypes.c_int),        # 1-based, can be -1 when invalid
        ("mTimeIntoLap", ctypes.c_double),       # estimated time into lap
        ("mEstimatedLapTime", ctypes.c_double),  # estimated laptime used for "time behind" and "time into lap" (note: this may changed based on vehicle and setup!?)
        ("mPitGroup", ctypes.c_char*24),         # pit group (same as team name unless pit is shared)
        ("mFlag", ctypes.c_ubyte),               # primary flag being shown to vehicle (currently only 0=green or 6 = blue)
        ("mUnderYellow", ctypes.c_bool),         # whether this car has taken a full-course caution flag at the start/finish line
        ("mCountLapFlag", ctypes.c_ubyte),       # 0 = do not count lap or time, 1 = count lap but not time, 2 = count lap and time
        ("mInGarageStall", ctypes.c_bool),       # appears to be within the correct garage stall
        ("mUpgradePack", ctypes.c_ubyte*16),     # Coded upgrades
        ("mPitLapDist", ctypes.c_float),         # location of pit in terms of lap distance
        ("mBestLapSector1", ctypes.c_float),     # sector 1 time from best lap (not necessarily the best sector 1 time)
        ("mBestLapSector2", ctypes.c_float),     # sector 2 time from best lap (not necessarily the best sector 2 time)
        ("mExpansion", ctypes.c_ubyte*48),       # for future use
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2PhysicsOptions(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mTractionControl", ctypes.c_ubyte),          # 0 (off) - 3 (high)
        ("mAntiLockBrakes", ctypes.c_ubyte),           # 0 (off) - 2 (high)
        ("mStabilityControl", ctypes.c_ubyte),         # 0 (off) - 2 (high)
        ("mAutoShift", ctypes.c_ubyte),                # 0 (off), 1 (upshifts), 2 (downshifts), 3 (all)
        ("mAutoClutch", ctypes.c_ubyte),               # 0 (off), 1 (on)
        ("mInvulnerable", ctypes.c_ubyte),             # 0 (off), 1 (on)
        ("mOppositeLock", ctypes.c_ubyte),             # 0 (off), 1 (on)
        ("mSteeringHelp", ctypes.c_ubyte),             # 0 (off) - 3 (high)
        ("mBrakingHelp", ctypes.c_ubyte),              # 0 (off) - 2 (high)
        ("mSpinRecovery", ctypes.c_ubyte),             # 0 (off), 1 (on)
        ("mAutoPit", ctypes.c_ubyte),                  # 0 (off), 1 (on)
        ("mAutoLift", ctypes.c_ubyte),                 # 0 (off), 1 (on)
        ("mAutoBlip", ctypes.c_ubyte),                 # 0 (off), 1 (on)
        ("mFuelMult", ctypes.c_ubyte),                 # fuel multiplier (0x-7x)
        ("mTireMult", ctypes.c_ubyte),                 # tire wear multiplier (0x-7x)
        ("mMechFail", ctypes.c_ubyte),                 # mechanical failure setting; 0 (off), 1 (normal), 2 (timescaled)
        ("mAllowPitcrewPush", ctypes.c_ubyte),         # 0 (off), 1 (on)
        ("mRepeatShifts", ctypes.c_ubyte),             # accidental repeat shift prevention (0-5; see PLR file)
        ("mHoldClutch", ctypes.c_ubyte),               # for auto-shifters at start of race: 0 (off), 1 (on)
        ("mAutoReverse", ctypes.c_ubyte),              # 0 (off), 1 (on)
        ("mAlternateNeutral", ctypes.c_ubyte),         # Whether shifting up and down simultaneously equals neutral
        ("mAIControl", ctypes.c_ubyte),                # Whether player vehicle is currently under AI control
        ("mUnused1", ctypes.c_ubyte),                  #
        ("mUnused2", ctypes.c_ubyte),                  #
        ("mManualShiftOverrideTime", ctypes.c_float),  # time before auto-shifting can resume after recent manual shift
        ("mAutoShiftOverrideTime", ctypes.c_float),    # time before manual shifting can resume after recent auto shift
        ("mSpeedSensitiveSteering", ctypes.c_float),   # 0.0 (off) - 1.0
        ("mSteerRatioSpeed", ctypes.c_float),          # speed (m/s) under which lock gets expanded to full
    ]


# untranslated [StructLayout(LayoutKind.Sequential, Pack = 4)]
class rF2TrackRulesAction(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mCommand", ctypes.c_int),  # recommended action
        ("mID", ctypes.c_int),       # slot ID if applicable
        ("mET", ctypes.c_double),    # elapsed time that event occurred, if applicable
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2TrackRulesParticipant(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mID", ctypes.c_int),                          # slot ID
        ("mFrozenOrder", ctypes.c_short),               # 0-based place when caution came out (not valid for formation laps)
        ("mPlace", ctypes.c_short),                     # 1-based place (typically used for the initialization of the formation lap track order)
        ("mYellowSeverity", ctypes.c_float),            # a rating of how much this vehicle is contributing to a yellow flag (the sum of all vehicles is compared to TrackRulesV01::mSafetyCarThreshold)
        ("mCurrentRelativeDistance", ctypes.c_double),  # equal to ( ( ScoringInfoV01::mLapDist * this->mRelativeLaps ) + VehicleScoringInfoV01::mLapDist )
        ("mRelativeLaps", ctypes.c_int),                # current formation/caution laps relative to safety car (should generally be zero except when safety car crosses s/f line); this can be decremented to implement "wave around" or "beneficiary rule" (a.k.a. "lucky dog" or "free pass")
        ("mColumnAssignment", ctypes.c_int),            # which column (line/lane) that participant is supposed to be in
        ("mPositionAssignment", ctypes.c_int),          # 0-based position within column (line/lane) that participant is supposed to be located at (-1 is invalid)
        ("mPitsOpen", ctypes.c_ubyte),                  # whether the rules allow this particular vehicle to enter pits right now (input is 2=false or 3=true; if you want to edit it, set to 0=false or 1 = true)
        ("mUpToSpeed", ctypes.c_bool),                  # while in the frozen order, this flag indicates whether the vehicle can be followed (this should be false for somebody who has temporarily spun and hasn't gotten back up to speed yet)
        ("mUnused", ctypes.c_bool*2),                   #
        ("mGoalRelativeDistance", ctypes.c_double),     # calculated based on where the leader is, and adjusted by the desired column spacing and the column/position assignments
        ("mMessage", ctypes.c_char*96),                 # a message for this participant to explain what is going on it will get run through translator on client machines
        ("mExpansion", ctypes.c_ubyte*192),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2TrackRules(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mCurrentET", ctypes.c_double),                   # current time
        ("mStage", ctypes.c_int),                          # current stage
        ("mPoleColumn", ctypes.c_int),                     # column assignment where pole position seems to be located
        ("mNumActions", ctypes.c_int),                     # number of recent actions
        ("pointer1", ctypes.c_ubyte*8),
        ("mNumParticipants", ctypes.c_int),                # number of participants (vehicles)
        ("mYellowFlagDetected", ctypes.c_bool),            # whether yellow flag was requested or sum of participant mYellowSeverity's exceeds mSafetyCarThreshold
        ("mYellowFlagLapsWasOverridden", ctypes.c_ubyte),  # whether mYellowFlagLaps (below) is an admin request (0=no 1=yes 2 = clear yellow)
        ("mSafetyCarExists", ctypes.c_bool),               # whether safety car even exists
        ("mSafetyCarActive", ctypes.c_bool),               # whether safety car is active
        ("mSafetyCarLaps", ctypes.c_int),                  # number of laps
        ("mSafetyCarThreshold", ctypes.c_float),           # the threshold at which a safety car is called out (compared to the sum of TrackRulesParticipantV01::mYellowSeverity for each vehicle)
        ("mSafetyCarLapDist", ctypes.c_double),            # safety car lap distance
        ("mSafetyCarLapDistAtStart", ctypes.c_float),      # where the safety car starts from
        ("mPitLaneStartDist", ctypes.c_float),             # where the waypoint branch to the pits breaks off (this may not be perfectly accurate)
        ("mTeleportLapDist", ctypes.c_float),              # the front of the teleport locations (a useful first guess as to where to throw the green flag)
        ("mInputExpansion", ctypes.c_ubyte*256),
        ("mYellowFlagState", ctypes.c_byte),               # see ScoringInfoV01 for values
        ("mYellowFlagLaps", ctypes.c_short),               # suggested number of laps to run under yellow (may be passed in with admin command)
        ("mSafetyCarInstruction", ctypes.c_int),           # 0=no change, 1=go active, 2 = head for pits
        ("mSafetyCarSpeed", ctypes.c_float),               # maximum speed at which to drive
        ("mSafetyCarMinimumSpacing", ctypes.c_float),      # minimum spacing behind safety car (-1 to indicate no limit)
        ("mSafetyCarMaximumSpacing", ctypes.c_float),      # maximum spacing behind safety car (-1 to indicate no limit)
        ("mMinimumColumnSpacing", ctypes.c_float),         # minimum desired spacing between vehicles in a column (-1 to indicate indeterminate/unenforced)
        ("mMaximumColumnSpacing", ctypes.c_float),         # maximum desired spacing between vehicles in a column (-1 to indicate indeterminate/unenforced)
        ("mMinimumSpeed", ctypes.c_float),                 # minimum speed that anybody should be driving (-1 to indicate no limit)
        ("mMaximumSpeed", ctypes.c_float),                 # maximum speed that anybody should be driving (-1 to indicate no limit)
        ("mMessage", ctypes.c_char*96),                    # a message for everybody to explain what is going on (which will get run through translator on client machines)
        ("pointer2", ctypes.c_ubyte*8),
        ("mInputOutputExpansion", ctypes.c_ubyte*256),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2PitMenu(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mCategoryIndex", ctypes.c_int),     # index of the current category
        ("mCategoryName", ctypes.c_char*32),  # name of the current category (untranslated)
        ("mChoiceIndex", ctypes.c_int),       # index of the current choice (within the current category)
        ("mChoiceString", ctypes.c_char*32),  # name of the current choice (may have some translated words)
        ("mNumChoices", ctypes.c_int),        # total number of choices (0 < = mChoiceIndex < mNumChoices)
        ("mExpansion", ctypes.c_ubyte*256),   # for future use
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2WeatherControlInfo(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mET", ctypes.c_double),                      # when you want this weather to take effect
        ("mRaining", ctypes.c_double*9),               # rain (0.0-1.0) at different nodes
        ("mCloudiness", ctypes.c_double),              # general cloudiness (0.0=clear to 1.0 = dark)
        ("mAmbientTempK", ctypes.c_double),            # ambient temperature (Kelvin)
        ("mWindMaxSpeed", ctypes.c_double),            # maximum speed of wind (ground speed, but it affects how fast the clouds move, too)
        ("mApplyCloudinessInstantly", ctypes.c_bool),  # preferably we roll the new clouds in, but you can instantly change them now
        ("mUnused1", ctypes.c_bool),
        ("mUnused2", ctypes.c_bool),
        ("mUnused3", ctypes.c_bool),
        ("mExpansion", ctypes.c_ubyte*508),            # future use (humidity, pressure, air density, etc.)
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2MappedBufferVersionBlock(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2MappedBufferVersionBlockWithSize(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mBytesUpdatedHint", ctypes.c_int),     # How many bytes of the structure were written during the last update.
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Telemetry(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mBytesUpdatedHint", ctypes.c_int),     # How many bytes of the structure were written during the last update.
        ("mNumVehicles", ctypes.c_int),          # current number of vehicles
        ("mVehicles", rF2VehicleTelemetry*rFactor2Constants.MAX_MAPPED_VEHICLES),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Scoring(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mBytesUpdatedHint", ctypes.c_int),     # How many bytes of the structure were written during the last update.
        ("mScoringInfo", rF2ScoringInfo),
        ("mVehicles", rF2VehicleScoring*rFactor2Constants.MAX_MAPPED_VEHICLES),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Rules(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mBytesUpdatedHint", ctypes.c_int),     # How many bytes of the structure were written during the last update.
        ("mTrackRules", rF2TrackRules),
        ("mActions", rF2TrackRulesAction*rFactor2Constants.MAX_MAPPED_VEHICLES),
        ("mParticipants", rF2TrackRulesParticipant*rFactor2Constants.MAX_MAPPED_VEHICLES),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2ForceFeedback(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mForceValue", ctypes.c_double),        # Current FFB value reported via InternalsPlugin::ForceFeedback.
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2GraphicsInfo(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mCamPos", rF2Vec3),                # camera position
        ("mCamOri", rF2Vec3*3),              # rows of orientation matrix (use TelemQuat conversions if desired), also converts local
        ("mHWND", ctypes.c_ubyte*8),         # app handle
        ("mAmbientRed", ctypes.c_double),
        ("mAmbientGreen", ctypes.c_double),
        ("mAmbientBlue", ctypes.c_double),
        ("mID", ctypes.c_int),               # slot ID being viewed (-1 if invalid)
        ("mCameraType", ctypes.c_int),       # see above comments for possible values
        ("mExpansion", ctypes.c_ubyte*128),  # for future use (possibly camera name)
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Graphics(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mGraphicsInfo", rF2GraphicsInfo),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2PitInfo(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mPitMenu", rF2PitMenu),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Weather(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mTrackNodeSize", ctypes.c_double),
        ("mWeatherInfo", rF2WeatherControlInfo),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, Pack = 4)]
class rF2TrackedDamage(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mMaxImpactMagnitude", ctypes.c_double),          # Max impact magnitude.  Tracked on every telemetry update, and reset on visit to pits or Session restart.
        ("mAccumulatedImpactMagnitude", ctypes.c_double),  # Accumulated impact magnitude.  Tracked on every telemetry update, and reset on visit to pits or Session restart.
    ]


# untranslated [StructLayout(LayoutKind.Sequential, Pack = 4)]
class rF2VehScoringCapture(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mID", ctypes.c_int),             # slot ID (note that it can be re-used in multiplayer after someone leaves)
        ("mPlace", ctypes.c_ubyte),
        ("mIsPlayer", ctypes.c_bool),
        ("mFinishStatus", ctypes.c_byte),  # 0=none, 1=finished, 2=dnf, 3 = dq
    ]


# untranslated [StructLayout(LayoutKind.Sequential, Pack = 4)]
class rF2SessionTransitionCapture(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mGamePhase", ctypes.c_ubyte),
        ("mSession", ctypes.c_int),
        ("mNumScoringVehicles", ctypes.c_int),
        ("mScoringVehicles", rF2VehScoringCapture*rFactor2Constants.MAX_MAPPED_VEHICLES),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2Extended(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),                             # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),                               # Incremented after buffer write is done.
        ("mVersion", ctypes.c_char*12),                                     # API version
        ("is64bit", ctypes.c_bool),                                         # Is 64bit plugin?
        ("mPhysics", rF2PhysicsOptions),
        ("mTrackedDamages", rF2TrackedDamage*rFactor2Constants.MAX_MAPPED_IDS),
        ("mInRealtimeFC", ctypes.c_bool),                                   # in realtime as opposed to at the monitor (reported via last EnterRealtime/ExitRealtime calls).
        ("mMultimediaThreadStarted", ctypes.c_bool),                        # multimedia thread started (reported via ThreadStarted/ThreadStopped calls).
        ("mSimulationThreadStarted", ctypes.c_bool),                        # simulation thread started (reported via ThreadStarted/ThreadStopped calls).
        ("mSessionStarted", ctypes.c_bool),                                 # Set to true on Session Started, set to false on Session Ended.
        ("mTicksSessionStarted", ctypes.c_ulonglong),                       # Ticks when session started.
        ("mTicksSessionEnded", ctypes.c_ulonglong),                         # Ticks when session ended.
        ("mSessionTransitionCapture", rF2SessionTransitionCapture),         # Contains partial internals capture at session transition time.
        ("mDisplayedMessageUpdateCapture", ctypes.c_char*128),
        ("mDirectMemoryAccessEnabled", ctypes.c_bool),
        ("mTicksStatusMessageUpdated", ctypes.c_ulonglong),                 # Ticks when status message was updated;
        ("mStatusMessage", ctypes.c_char*rFactor2Constants.MAX_STATUS_MSG_LEN),
        ("mTicksLastHistoryMessageUpdated", ctypes.c_ulonglong),            # Ticks when last message history message was updated;
        ("mLastHistoryMessage", ctypes.c_char*rFactor2Constants.MAX_STATUS_MSG_LEN),
        ("mCurrentPitSpeedLimit", ctypes.c_float),                          # speed limit m/s.
        ("mSCRPluginEnabled", ctypes.c_bool),                               # Is Stock Car Rules plugin enabled?
        ("mSCRPluginDoubleFileType", ctypes.c_int),                         # Stock Car Rules plugin DoubleFileType value, only meaningful if mSCRPluginEnabled is true.
        ("mTicksLSIPhaseMessageUpdated", ctypes.c_ulonglong),               # Ticks when last LSI phase message was updated.
        ("mLSIPhaseMessage", ctypes.c_char*rFactor2Constants.MAX_RULES_INSTRUCTION_MSG_LEN),
        ("mTicksLSIPitStateMessageUpdated", ctypes.c_ulonglong),            # Ticks when last LSI pit state message was updated.
        ("mLSIPitStateMessage", ctypes.c_char*rFactor2Constants.MAX_RULES_INSTRUCTION_MSG_LEN),
        ("mTicksLSIOrderInstructionMessageUpdated", ctypes.c_ulonglong),    # Ticks when last LSI order instruction message was updated.
        ("mLSIOrderInstructionMessage", ctypes.c_char*rFactor2Constants.MAX_RULES_INSTRUCTION_MSG_LEN),
        ("mTicksLSIRulesInstructionMessageUpdated", ctypes.c_ulonglong),    # Ticks when last FCY rules message was updated.  Currently, only SCR plugin sets that.
        ("mLSIRulesInstructionMessage", ctypes.c_char*rFactor2Constants.MAX_RULES_INSTRUCTION_MSG_LEN),
        ("mUnsubscribedBuffersMask", ctypes.c_int),                         # Currently active UnsbscribedBuffersMask value.  This will be allowed for clients to write to in the future, but not yet.
        ("mHWControlInputEnabled", ctypes.c_bool),                          # HWControl input buffer is enabled.
        ("mWeatherControlInputEnabled", ctypes.c_bool),                     # WeatherControl input buffer is enabled.
        ("mRulesControlInputEnabled", ctypes.c_bool),                       # RulesControl input buffer is enabled.
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2HWControl(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mLayoutVersion", ctypes.c_int),
        ("mControlName", ctypes.c_char*rFactor2Constants.MAX_HWCONTROL_NAME_LEN),
        ("mfRetVal", ctypes.c_double),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2WeatherControl(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mLayoutVersion", ctypes.c_int),
        ("mWeatherInfo", rF2WeatherControlInfo),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2RulesControl(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mLayoutVersion", ctypes.c_int),
        ("mTrackRules", rF2TrackRules),
        ("mActions", rF2TrackRulesAction*rFactor2Constants.MAX_MAPPED_VEHICLES),
        ("mParticipants", rF2TrackRulesParticipant*rFactor2Constants.MAX_MAPPED_VEHICLES),
    ]


# untranslated [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
class rF2PluginControl(ctypes.Structure):
    _pack_ = 4
    _fields_ = [
        ("mVersionUpdateBegin", ctypes.c_uint),  # Incremented right before buffer is written to.
        ("mVersionUpdateEnd", ctypes.c_uint),    # Incremented after buffer write is done.
        ("mLayoutVersion", ctypes.c_int),
        ("mRequestEnableBuffersMask", ctypes.c_int),
        ("mRequestHWControlInput", ctypes.c_ubyte),
        ("mRequestWeatherControlInput", ctypes.c_ubyte),
        ("mRequestRulesControlInput", ctypes.c_ubyte),
    ]


class SimInfo:
    """Simulation info from shared memory"""

    def __init__(self):
        self._rf2_tele = mmap.mmap(
            fileno=0,
            length=ctypes.sizeof(rF2Telemetry),
            tagname=rFactor2Constants.MM_TELEMETRY_FILE_NAME,
        )
        self.Rf2Tele = rF2Telemetry.from_buffer(self._rf2_tele)

        self._rf2_scor = mmap.mmap(
            fileno=0,
            length=ctypes.sizeof(rF2Scoring),
            tagname=rFactor2Constants.MM_SCORING_FILE_NAME,
        )
        self.Rf2Scor = rF2Scoring.from_buffer(self._rf2_scor)

        self._rf2_ext = mmap.mmap(
            fileno=0,
            length=ctypes.sizeof(rF2Extended),
            tagname=rFactor2Constants.MM_EXTENDED_FILE_NAME,
        )
        self.Rf2Ext = rF2Extended.from_buffer(self._rf2_ext)

    def close(self):
        """Close memory map"""
        self.Rf2Tele = None
        self.Rf2Scor = None
        self.Rf2Ext = None
        try:  # this did not help with the errors
            self._rf2_tele.close()
            self._rf2_scor.close()
            self._rf2_ext.close()
        except BufferError as e:
            print("Error:", e)

    def __del__(self):
        self.close()


def test():
    """Example usage"""
    info = SimInfo()
    version = bytes(info.Rf2Ext.mVersion).decode().rstrip()
    clutch = info.Rf2Tele.mVehicles[0].mUnfilteredClutch  # 1.0 clutch down, 0 clutch up
    gear = info.Rf2Tele.mVehicles[0].mGear  # -1 to 6
    print(f"API version: {version if version else 'not found'}")
    print(f"Gear: {gear}, Clutch position: {clutch}")
    print(f"Unsubscribed buffers: {SubscribedBuffer(info.Rf2Ext.mUnsubscribedBuffersMask)}")


if __name__ == "__main__":
    test()

```

---

## `pyRfactor2SharedMemory\requirements.txt`

```
astroid==2.2.5
colorama==0.4.1
isort==4.3.21
lazy-object-proxy==1.4.2
mccabe==0.6.1
psutil==5.7.0
pylint==2.3.1
setuptools==65.5.1
six==1.12.0
typed-ast==1.4.0
wrapt==1.11.2

```

---

## `pyRfactor2SharedMemory\sharedMemoryAPI.py`

```
"""
Inherit Python mapping of The Iron Wolf's rF2 Shared Memory Tools
and add access functions to it.
"""
# pylint: disable=invalid-name

import psutil

try:
    from . import rF2data
except ImportError:  # standalone, not package
    import rF2data


class SimInfoAPI(rF2data.SimInfo):
    """
    API for rF2 shared memory
    """
    __HELP = "\nShared Memory is installed by Crew Chief or you can install it yourself.\n" \
        "Please update rFactor2SharedMemoryMapPlugin64.dll, see\n" \
        "https://forum.studio-397.com/index.php?threads/rf2-shared-memory-tools-for-developers.54282/"

    sharedMemoryVerified = False
    minimumSupportedVersionParts = ['3', '6', '0', '0']
    rf2_pid = None          # Once we've found rF2 running
    rf2_pid_counter = 0     # Counter to check if running
    rf2_running = False

    def __init__(self):
        rF2data.SimInfo.__init__(self)
        self.versionCheckMsg = self.versionCheck()
        self.__find_rf2_pid()

    def versionCheck(self):
        """
        Lifted from
        https://gitlab.com/mr_belowski/CrewChiefV4/blob/master/CrewChiefV4/RF2/RF2GameStateMapper.cs
        and translated.
        """
        self.sharedMemoryVerified = False    # Verify every time it is called.

        versionStr = Cbytestring2Python(self.Rf2Ext.mVersion)
        msg = ''

        if versionStr == '':
            msg = "\nrFactor 2 Shared Memory not present." + self.__HELP
            return msg

        versionParts = versionStr.split('.')
        if len(versionParts) != 4:
            msg = "Corrupt or leaked rFactor 2 Shared Memory.  Version string: " \
                + versionStr + self.__HELP
            return msg

        smVer = 0
        minVer = 0
        partFactor = 1
        for i in range(3, -1, -1):
            versionPart = 0
            try:
                versionPart = int(versionParts[i])
            except BaseException:
                msg = "Corrupt or leaked rFactor 2 Shared Memory version.  Version string: " \
                    + versionStr + self.__HELP
                return msg

            smVer += (versionPart * partFactor)
            minVer += (int(self.minimumSupportedVersionParts[i]) * partFactor)
            partFactor *= 100

        if smVer < minVer:
            minVerStr = ".".join(self.minimumSupportedVersionParts)
            msg = "Unsupported rFactor 2 Shared Memory version: " \
                + versionStr \
                + "  Minimum supported version is: " \
                + minVerStr + self.__HELP
        else:
            msg = "\nrFactor 2 Shared Memory\nversion: " + versionStr + " 64bit."
            if self.Rf2Ext.mDirectMemoryAccessEnabled:
                if self.Rf2Ext.mSCRPluginEnabled:
                    msg += "  Stock Car Rules plugin enabled. (DFT:%d" % \
                        self.Rf2Ext.mSCRPluginDoubleFileType
                else:
                    msg += "  DMA enabled."
            if self.Rf2Ext.is64bit == 0:
                msg += "\nOnly 64bit version of rFactor 2 is supported."
            else:
                self.sharedMemoryVerified = True

        return msg

    ###########################################################
    def __find_rf2_pid(self):
        """ Find the process ID for rfactor2.exe.  Takes a while """
        for pid in psutil.pids():
            try:
                p = psutil.Process(pid)
            except psutil.NoSuchProcess:
                continue
            if p.name().lower().startswith('rfactor2.exe'):
                self.rf2_pid = pid
                break

    def __playersDriverNum(self):
        """ Find the player's driver number """
        for _player in range(50):  # self.Rf2Tele.mVehicles[0].mNumVehicles:
            if self.Rf2Scor.mVehicles[_player].mIsPlayer:
                break
        return _player

    ###########################################################
    # Access functions

    def isRF2running(self, find_counter=200, found_counter=5):
        """
        Both "rFactor 2 Launcher" and "rf2" processes are found
        whether it's the launcher or the game that's running BUT
        rfactor2.exe is only present if the game is running.
        Beacuse this takes some time, control how often it's checked using:
        find_counter: how often to check if rF2 is not running
        found_counter: how often to check once rF2 is running
        """
        if self.rf2_pid_counter == 0:  # first time
            self.rf2_pid_counter = find_counter
        if self.isSharedMemoryAvailable():
            # No need to check if Shared Memory is OK!
            self.rf2_running = True
        elif self.rf2_pid:
            if self.rf2_pid_counter >= found_counter:
                self.rf2_pid_counter = 0
                try:
                    p = psutil.Process(self.rf2_pid)
                except psutil.NoSuchProcess:
                    self.rf2_pid = None
                    return False
                if p.name().lower().startswith('rfactor2.exe'):
                    self.rf2_running = True
        else:
            if self.rf2_pid_counter >= find_counter:
                self.rf2_pid_counter = 0
                self.__find_rf2_pid()
                self.rf2_running = False
        self.rf2_pid_counter += 1
        return self.rf2_running

    def isSharedMemoryAvailable(self):
        """
        True: The correct memory map is loaded
        """
        self.versionCheck()
        return self.sharedMemoryVerified

    def isTrackLoaded(self):
        """
        True: rF2 is running and the track is loaded
        """
        started = self.Rf2Ext.mSessionStarted
        return started != 0

    def isOnTrack(self):
        """
        True: rF2 is running and the player is on track
        """
        realtime = self.Rf2Ext.mInRealtimeFC
        return realtime != 0

    def isAiDriving(self):
        """
        True: rF2 is running and the player is on track
        """
        return self.Rf2Scor.mVehicles[self.__playersDriverNum()].mControl == 1
        # who's in control: -1=nobody (shouldn't get this), 0=local player,
        # 1=local AI, 2=remote, 3=replay (shouldn't get this)

        # didn't work self.Rf2Ext.mPhysics.mAIControl

    def driverName(self):
        """
        Get the player's name
        """
        return Cbytestring2Python(
            self.Rf2Scor.mVehicles[self.__playersDriverNum()].mDriverName)

    def playersVehicleTelemetry(self):
        """ Get the variable for the player's vehicle """
        self.__playersDriverNum()
        return self.Rf2Tele.mVehicles[self.__playersDriverNum()]

    def playersVehicleScoring(self):
        """ Get the variable for the player's vehicle """
        self.__playersDriverNum()
        return self.Rf2Scor.mVehicles[self.__playersDriverNum()]

    def vehicleName(self):
        """
        Get the vehicle's name
        """
        return Cbytestring2Python(
            self.Rf2Scor.mVehicles[self.__playersDriverNum()].mVehicleName)

    def close(self):
        # This didn't help with the errors
        try:
            self._rf2_tele.close()
            self._rf2_scor.close()
            self._rf2_ext.close()
        except BufferError:  # "cannot close exported pointers exist"
            pass

    def __del__(self):
        self.close()


def Cbytestring2Python(bytestring):
    """
    C string to Python string
    """
    try:
        return bytes(bytestring).partition(b'\0')[0].decode('utf_8').rstrip()
    except BaseException:
        pass
    try:    # Codepage 1252 includes Scandinavian characters
        return bytes(bytestring).partition(b'\0')[0].decode('cp1252').rstrip()
    except BaseException:
        pass
    try:    # OK, struggling, just ignore errors
        return bytes(bytestring).partition(b'\0')[
            0].decode('utf_8', 'ignore').rstrip()
    except Exception as e:
        print('Trouble decoding a string')
        print(e)


def test_main():    # pylint: disable=too-many-statements
    """ Example usage """
    info = SimInfoAPI()
    if info.isRF2running():
        print('rfactor2.exe is running')
        print(info.versionCheckMsg, '\n')
        if info.isSharedMemoryAvailable():
            print('Memory map is loaded')
            version = Cbytestring2Python(info.Rf2Ext.mVersion)
            # 2019/04/23:  3.5.0.9
            print('Shared memory version:', version)

            if info.isTrackLoaded():
                trackName = Cbytestring2Python(
                    info.Rf2Scor.mScoringInfo.mTrackName)
                print('%s is loaded' % trackName)
                if info.isOnTrack():
                    driver = Cbytestring2Python(
                        info.playersVehicleScoring().mDriverName)
                    print('Driver "%s" is on track' % driver)
                    clutch = info.playersVehicleTelemetry().mUnfilteredClutch
                    # 1.0 clutch down, 0 clutch up

                    driver = Cbytestring2Python(
                        info.playersVehicleScoring().mDriverName)
                    gear = info.playersVehicleTelemetry().mGear
                    print('Driver: "%s", Gear: %d, Clutch position: %d' %
                          (driver, gear, clutch))

                    # Test that memory map can be poked
                    info.playersVehicleTelemetry().mGear = 1
                    gear = info.playersVehicleTelemetry().mGear  # -1 to 6
                    assert info.playersVehicleTelemetry().mGear == 1
                    info.playersVehicleTelemetry().mGear = 2
                    assert info.playersVehicleTelemetry().mGear == 2
                    gear = info.playersVehicleTelemetry().mGear  # -1 to 6
                    info.playersVehicleTelemetry().mGear = 1
                    assert info.playersVehicleTelemetry().mGear == 1

                    _vehicleName = Cbytestring2Python(
                        info.playersVehicleScoring().mVehicleName)
                    _vehicleClass = Cbytestring2Python(
                        info.playersVehicleScoring().mVehicleClass)

                    print('vehicleName:', _vehicleName)
                    print('vehicleClass:', _vehicleClass)

                    started = info.Rf2Ext.mSessionStarted
                    print('SessionStarted:', started)
                    realtime = info.Rf2Ext.mInRealtimeFC
                    print('InRealtimeFC:', realtime)
                    if info.isAiDriving():
                        print('AI is driving the car')
                    else:
                        print('Car not under AI control')
                else:
                    print('Driver is not on track')
            else:
                print('Track is not loaded')

            print('\nBreaking the version string...')
            info.Rf2Ext.mVersion[0] = 32

            assert not info.isSharedMemoryAvailable()
            print('\n' + info.versionCheck())
            info.Rf2Ext.mVersion[0] = 51  # restore it

            info.Rf2Ext.mVersion[0] = 50
            assert not info.isSharedMemoryAvailable()
            print('\n' + info.versionCheck())
            info.Rf2Ext.mVersion[0] = 51  # restore it

            info.Rf2Ext.mVersion[2] = 53
            assert not info.isSharedMemoryAvailable()
            print('\n' + info.versionCheck())
            info.Rf2Ext.mVersion[2] = 54  # restore it

            print('\nBreaking 64 bit info...')
            info.Rf2Ext.is64bit = 0
            assert not info.isSharedMemoryAvailable()
            print(info.versionCheck())
            info.Rf2Ext.is64bit = 1

            print('\nPit Menu')
            while True:
                if info.Rf2PitMenu.changed:
                    print(Cbytestring2Python(
                        info.Rf2PitMenu.mCategoryName))
                    info.Rf2PitMenu.changed = 0

            print('\nOK')
        else:
            print('Incorrect shared memory')
    else:
        print('rFactor 2 not running')

    s = bytearray(range(0xA1, 0xff))
    print(Cbytestring2Python(s))
    return 'OK'


if __name__ == '__main__':
    test_main()

```

---

## `pyRfactor2SharedMemory\tests\__init__.py`

```

```

---

## `pyRfactor2SharedMemory\tests\test_sharedMemoryAPI.py`

```
import unittest

from sharedMemoryAPI import test_main, SimInfoAPI, Cbytestring2Python

VERSION_STRING = '3.6.0.0     '
TRACK_NAME = 'Test Track'


def str_to_byte_array(string):
    x = bytearray(string, 'utf-8')
    byte_array = bytearray()
    for i, ch in enumerate(x):
        byte_array[i] = ch
    return byte_array


class Test_sharedMemoryAPI(unittest.TestCase):
    def test_sharedMemoryAPI_main_runs(self):
        """ Preliminary test - does main run? """
        root = test_main()
        assert root is not None

    def test_pokeMemoryMap(self):
        info = SimInfoAPI()
        x = bytearray(VERSION_STRING, 'utf-8')
        for i, ch in enumerate(x):
            info.Rf2Ext.mVersion[i] = ch
        #info.Rf2Ext.mVersion = str_to_byte_array(VERSION_STRING)
        __ = VERSION_STRING.encode()
        info.Rf2Ext.is64bit = 1
        print(info.isSharedMemoryAvailable())
        assert info.isSharedMemoryAvailable() is not None

    def test_is_track_loaded(self):
        info = SimInfoAPI()
        info.Rf2Ext.mSessionStarted = 1
        assert info.isTrackLoaded()

    def test_track_name(self):
        info = SimInfoAPI()
        x = bytearray(TRACK_NAME, 'utf-8')
        for i, ch in enumerate(x):
            info.Rf2Scor.mScoringInfo.mTrackName[i] = ch
        trackName = Cbytestring2Python(
            info.Rf2Scor.mScoringInfo.mTrackName)
        assert trackName

    def test_is_on_track(self):
        info = SimInfoAPI()
        info.Rf2Ext.mInRealtimeFC = 1
        assert info.isOnTrack()


if __name__ == '__main__':
    unittest.main(exit=False)

```

---

## `services\__init__.py`

```

```

---

## `simulators\__init__.py`

```

```

---

## `simulators\__pycache__\__init__.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `simulators\lmu\__init__.py`

```

```

---

## `simulators\lmu\__pycache__\__init__.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `simulators\lmu\__pycache__\collector.cpython-313.pyc`

_[Skipped binary file: application/octet-stream]_

---

## `simulators\lmu\collector.py`

```
# rw_backend/simulators/lmu/collector.py

import threading
import time
from queue import Queue
from rw_backend.pyRfactor2SharedMemory.sharedMemoryAPI import SimInfoAPI

class LMUCollector(threading.Thread):
    """
    A simple, "dumb" worker thread that reads all shared memory data
    at high frequency and puts it onto a queue for processing.
    """
    # --- THE FIX ---
    # The __init__ signature now correctly accepts `raw_data_queue`.
    def __init__(self, raw_data_queue: Queue):
        super().__init__(daemon=True)
        self.raw_data_queue = raw_data_queue
        self._running = threading.Event()
        self.info = None

    def run(self):
        print("[Collector] Thread started.", flush=True)
        self._running.set()
        self.info = SimInfoAPI()

        while self._running.is_set():
            try:
                if self.info.isSharedMemoryAvailable():
                    # Bundle all data structures the EventGenerator might need
                    raw_data_bundle = {
                        'telemetry': self.info.playersVehicleTelemetry(),
                        'scoring': self.info.Rf2Scor,
                        'extended': self.info.Rf2Ext
                    }
                    self.raw_data_queue.put(raw_data_bundle)
                    
                    # Poll at a high frequency when on track, lower when not
                    if self.info.Rf2Ext.mInRealtimeFC:
                        time.sleep(1 / 60)
                    else:
                        time.sleep(1 / 5)
                else:
                    time.sleep(2)
            except Exception as e:
                print(f"[Collector] Error: {e}", flush=True)
                time.sleep(5)
        
        if self.info:
            self.info.close()

    def stop(self):
        self._running.clear()
```

---

## `simulators\lmu\testing.md`

```
Excellent. With the code in place, we move to the most important part: the end-to-end verification test. This will confirm that every piece of the live data pipeline we just built is working in concert.

Here is your detailed guide for testing and verifying **Chunk 3**. Follow these steps in order.

---

### **Testing & Verification Plan for Chunk 3**

**Goal:** To prove that live data from the simulator is being collected by the Python backend, transmitted over WebSockets, received by the React frontend, and displayed correctly and in real-time on the "Live Transponder" screen.

#### **Phase 1: Setup**

1.  **Start the Simulator:** Launch Le Mans Ultimate. For now, just leave it on the main menu.
2.  **Start the Application:**
    *   Open your terminal to the project root (`raceworkshop-python/`).
    *   Ensure your Python virtual environment is activated.
    *   Run the development command:
        ```bash
        npm run dev
        ```
3.  **Arrange Your Windows:** For the best testing experience, arrange your screen so you can see three things at once:
    *   The RaceWorkshop application window.
    *   The terminal running the `npm run dev` command.
    *   The developer tools console for the RaceWorkshop UI (Right-click in the app -> "Inspect").

#### **Phase 2: Initial Connection Test**

This tests if the collector and WebSocket server start correctly and if the UI connects to them.

1.  **Check Terminal Logs:** Look at the terminal running `npm run dev`. You should see the following log lines appear, confirming the backend services have started:
    *   `[LMU Collector] Thread started.`
    *   `[Live Data Server] Starting WebSocket server on ws://localhost:8765`
    *   `[Status Handler] Status: disconnected, Message: Game not running...` (This might appear briefly before it connects).
    *   `[Status Handler] Status: connected, Message: In Menus / Spectating`

2.  **Navigate to the Transponder:** In the RaceWorkshop application, click on the "Le Mans Ultimate" icon in the sidebar, and then click on the "Transponder" tab.

3.  **Check Browser Console Logs:** Look at the developer tools console. You should see:
    *   `[Transponder] Mounting and starting telemetry...`
    *   `[Telemetry] Starting for lmu... Connecting to ws://localhost:8765`
    *   `[Telemetry] WebSocket connection established.`

4.  **Check Terminal Logs Again:** The `Live Data Server` should now report a client connection:
    *   `[Live Data Server] Client connected. Total clients: 1`

**‚úÖ Verification Point 1:** If you see all these logs, it confirms that the backend services started correctly and the frontend successfully established a WebSocket connection. The pipeline is open.

#### **Phase 3: Live Telemetry Test (On Track)**

This is the core test. We will go on track and verify that the data flows correctly.

1.  **Go On Track in LMU:**
    *   In Le Mans Ultimate, start any single-player session (a Practice session is perfect).
    *   Choose any car and track.
    *   Click "Drive" to load onto the track.

2.  **Observe the UI:** As soon as you are in the car on the track, the "Live Transponder" view should come to life. Verify the following:
    *   **Connection Status:** The status indicator at the top right should turn green and say "Live".
    *   **Session Info (Sidebar):** The "Track" and "Car" fields should update to show the correct information for your current session.
    *   **Live Data (Sidebar):** The "Fuel", "Tyre Pressures", "Current Lap" should all show initial, non-zero values.
    *   **Driving Data:** As you start driving, verify that **Speed** and **RPM** are updating smoothly and in real-time. Change gears and confirm the **Gear** indicator updates.

3.  **Observe the Terminal:** The status handler log should now be reporting:
    *   `[Status Handler] Status: connected, Message: Live on track`

**‚úÖ Verification Point 2:** If the UI is showing live, dynamic data that matches what you are doing in the game, it confirms that the `LMUCollector` is successfully reading shared memory and the data is being correctly transmitted and displayed.

#### **Phase 4: Lap Completion Test**

This tests the `lastLap` logic that will be crucial for our persistent lap recording in the next chunk.

1.  **Complete a Full Lap:** Drive a complete, valid lap in the simulator.
2.  **Cross the Start/Finish Line.**
3.  **Observe the UI:** The moment you cross the line to complete the lap, you should see a new row appear in the **Live Timing table**.
    *   The row should show "Lap 1".
    *   It should have a valid "Lap Time" and times for Sector 1, 2, and 3.
    *   The "Valid" indicator should be green.

4.  **Complete an Invalid Lap:** Drive another lap, but this time, go off track to invalidate it.
5.  **Cross the Start/Finish Line again.**
6.  **Observe the UI:** A new "Lap 2" row should appear, but this time the "Valid" indicator should be red.

**‚úÖ Verification Point 3:** If new lap rows are appearing in the timing table as you complete them, it confirms that the `lastLap` data is being correctly identified, packaged, sent, and rendered by the UI.

#### **Phase 5: Teardown Test**

This ensures the application cleans up after itself correctly.

1.  **Close the RaceWorkshop Application Window.**
2.  **Observe the Python Terminal:** You should immediately see the shutdown logs:
    *   `[Main] Window is closing. Stopping collector...`
    *   `[LMU Collector] Stop signal received.`
    *   `[LMU Collector] Thread stopped.`
3.  **Observe the Browser Console:** It might show a WebSocket disconnection error, which is expected and normal.
4.  **Observe Terminal 1 (Vite Server):** It should still be running, which is correct. You can stop it with `Ctrl+C`.

**‚úÖ Verification Point 4:** If the collector thread stops cleanly upon window close, it confirms our resource management is working correctly.

---

If you can successfully pass all these verification points, then **Chunk 3 is officially complete and successful**. We have a working, real-time telemetry application.

Please proceed with the test plan. Let me know the results or if you encounter any unexpected behavior at any step.
```

---

---

# daemon.py (FINAL ORCHESTRATOR - CORRECTED)

import time
from queue import Queue
from rw_backend.simulators.lmu.collector import LMUCollector
from rw_backend.generators.event_generator import EventGenerator
from rw_backend.database.manager import connect_db, close_db, initialize_database
from rw_backend.handlers.session_handler import SessionHandler
from rw_backend.handlers.stint_handler import StintHandler
from rw_backend.handlers.lap_handler import LapHandler
from rw_backend.handlers.live_data_handler import LiveDataHandler
from rw_backend.core.events import TelemetryUpdate, SessionEnded
from rw_backend.core.live_data_server import LiveDataServer

def run_daemon():
    # ... (This entire function remains unchanged)
    print("[Daemon] Starting background process with Event-Driven Architecture...", flush=True)
    initialize_database()
    connect_db()
    raw_data_queue = Queue()
    event_queue = Queue()
    live_data_server = LiveDataServer()
    session_handler = SessionHandler()
    stint_handler = StintHandler(session_handler)
    lap_handler = LapHandler(stint_handler)
    live_data_handler = LiveDataHandler(live_data_server, session_handler, lap_handler)
    handlers = [session_handler, stint_handler, lap_handler, live_data_handler]
    collector = LMUCollector(raw_data_queue=raw_data_queue)
    event_generator = EventGenerator(raw_data_queue=raw_data_queue, event_queue=event_queue)
    collector.start()
    event_generator.start()
    live_data_server.start()
    print("[Daemon] Event bus running. Monitoring for events...", flush=True)
    try:
        while True:
            event = event_queue.get()
            if not isinstance(event, TelemetryUpdate):
                print(f"[{time.strftime('%H:%M:%S')}] EVENT DISPATCH: {type(event).__name__}", flush=True)
            for handler in handlers:
                handler.handle_event(event)
    except KeyboardInterrupt:
        print("\n[Daemon] Shutdown signal received.", flush=True)
    finally:
        collector.stop()
        event_generator.stop()
        final_event = SessionEnded()
        for handler in handlers:
            handler.handle_event(final_event)
        close_db()
        print("[Daemon] Services shut down. Exiting.", flush=True)

# --- THE FIX ---
# This ensures the run_daemon() function is only called when
# the script is executed directly (e.g., "python daemon.py").
if __name__ == '__main__':
    run_daemon()

---

---

## main.py (DIAGNOSTIC LAUNCHER)

import webview
import os
import sys
import subprocess
from rw_backend.core.api_bridge import ApiBridge
from rw_backend.database.manager import initialize_database

daemon_process = None

def main():
    global daemon_process
    initialize_database()

    print("[Main] Launching background daemon process...", flush=True)
    try:
        python_executable = sys.executable
        command = [python_executable, "daemon.py"]
        
        # --- THE FIX FOR DEBUGGING ---
        # On Windows, we will temporarily remove all output redirection and
        # use the CREATE_NEW_CONSOLE flag. This will force a new, separate
        # console window to open for the daemon, where we are guaranteed to see its output.
        creationflags = 0
        if sys.platform == "win32":
            creationflags = subprocess.CREATE_NEW_CONSOLE
            
        daemon_process = subprocess.Popen(command, creationflags=creationflags)
        print(f"[Main] Daemon process started in new window with PID: {daemon_process.pid}", flush=True)

    except Exception as e:
        print(f"[Main] CRITICAL: Failed to launch daemon process: {e}", flush=True)
        return

    # --- REGULAR PYWEBVIEW SETUP (Unchanged) ---
    api_bridge = ApiBridge()
    is_dev = os.getenv("RACEWORKSHOP_DEV_MODE") == "1"
    url = "http://localhost:5173" if is_dev else 'frontend/dist/index.html'
    
    print(f"--- Starting in {'DEVELOPMENT' if is_dev else 'PRODUCTION'} mode ---", flush=True)
    print(f"--- Loading UI from: {url} ---", flush=True)
    
    window = webview.create_window('RaceWorkshop', url, js_api=api_bridge, width=1600, height=1200, min_size=(1024, 768))
    
    def on_closing():
        print("[Main] Window is closing. Terminating daemon process...", flush=True)
        if daemon_process:
            daemon_process.terminate()
            try:
                daemon_process.wait(timeout=5)
                print("[Main] Daemon process terminated gracefully.", flush=True)
            except subprocess.TimeoutExpired:
                print("[Main] Daemon process did not terminate gracefully, forcing kill.", flush=True)
                daemon_process.kill()
    
    window.events.closing += on_closing
    webview.start(debug=is_dev)

if __name__ == '__main__':
    main()

---

---
package.json

{
  "name": "raceworkshop-python",
  "version": "1.0.0",
  "description": "RaceWorkshop Desktop Application",
  "main": "main.py",
  "scripts": {
    "//-- SETUP --//": "",
    "postinstall": "cd frontend && npm install",
    "//-- DEVELOPMENT (Hot Reload) --//": "",
    "dev": "concurrently \"npm:dev:frontend\" \"npm:dev:backend\"",
    "dev:frontend": "cd frontend && npm run dev",
    "dev:backend": "cross-env RACEWORKSHOP_DEV_MODE=1 python main.py",
     "test:persistence:daemon": "python daemon.py",
    "test:persistence:gui": "python main.py",
    "//-- PRODUCTION --//": "",
    "start": "npm run build && python main.py",
    "build": "cd frontend && npm run build"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "concurrently": "^8.2.2",
    "cross-env": "^7.0.3"
  }
}

---

# setup.py
from setuptools import setup, find_packages

setup(
    name='raceworkshop-backend',
    version='0.1.0',
    packages=find_packages(),
)
---

## requirements.tsx

pywebview
peewee
Flask
websockets
pyinstaller
psutil

---



